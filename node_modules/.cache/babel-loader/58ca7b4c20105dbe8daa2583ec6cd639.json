{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { BehaviorSubject, combineLatest, from, map, of, switchMap, tap, toArray } from 'rxjs';\nimport { decorateDerive } from '@polkadot/api-derive';\nimport { memo, RpcCore } from '@polkadot/rpc-core';\nimport { WsProvider } from '@polkadot/rpc-provider';\nimport { expandMetadata, TypeRegistry, unwrapStorageType } from '@polkadot/types';\nimport { arrayChunk, arrayFlatten, assert, BN, BN_ZERO, compactStripLength, logger, u8aToHex } from '@polkadot/util';\nimport { createSubmittable } from \"../submittable/index.js\";\nimport { augmentObject } from \"../util/augmentObject.js\";\nimport { decorateSections } from \"../util/decorate.js\";\nimport { extractStorageArgs } from \"../util/validate.js\";\nimport { Events } from \"./Events.js\";\nimport { findCall, findError } from \"./find.js\"; // the max amount of keys/values that we will retrieve at once\n\nconst PAGE_SIZE_K = 1000; // limit aligned with the 1k on the node (trie lookups are heavy)\n\nconst PAGE_SIZE_V = 250; // limited since the data may be very large (e.g. misfiring elections)\n\nconst l = logger('api/init');\nlet instanceCounter = 0;\n\nfunction getAtQueryFn(api, {\n  method,\n  section\n}) {\n  assert(api.rx.query[section] && api.rx.query[section][method], () => `query.${section}.${method} is not available in this version of the metadata`);\n  return api.rx.query[section][method];\n}\n\nvar _instanceId = /*#__PURE__*/_classPrivateFieldLooseKey(\"instanceId\");\n\nvar _registry = /*#__PURE__*/_classPrivateFieldLooseKey(\"registry\");\n\nexport class Decorate extends Events {\n  // HACK Use BN import so decorateDerive works... yes, wtf.\n  // latest extrinsic version\n\n  /**\n   * This is the one and only method concrete children classes need to implement.\n   * It's a higher-order function, which takes one argument\n   * `method: Method extends (...args: any[]) => Observable<any>`\n   * (and one optional `options`), and should return the user facing method.\n   * For example:\n   * - For ApiRx, `decorateMethod` should just be identity, because the input\n   * function is already an Observable\n   * - For ApiPromise, `decorateMethod` should return a function that takes all\n   * the parameters from `method`, adds an optional `callback` argument, and\n   * returns a Promise.\n   *\n   * We could easily imagine other user-facing interfaces, which are simply\n   * implemented by transforming the Observable to Stream/Iterator/Kefir/Bacon\n   * via `decorateMethod`.\n   */\n\n  /**\n   * @description Create an instance of the class\n   *\n   * @param options Options object to create API instance or a Provider instance\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * import Api from '@polkadot/api/promise';\n   *\n   * const api = new Api().isReady();\n   *\n   * api.rpc.subscribeNewHeads((header) => {\n   *   console.log(`new block #${header.number.toNumber()}`);\n   * });\n   * ```\n   */\n  constructor(options, type, decorateMethod) {\n    var _options$source;\n\n    super();\n    Object.defineProperty(this, _instanceId, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _registry, {\n      writable: true,\n      value: void 0\n    });\n    this.__phantom = new BN(0);\n    this._consts = {};\n    this._derive = void 0;\n    this._errors = {};\n    this._events = {};\n    this._extrinsics = void 0;\n    this._extrinsicType = 4;\n    this._genesisHash = void 0;\n    this._isConnected = void 0;\n    this._isReady = false;\n    this._options = void 0;\n    this._query = {};\n    this._queryMulti = void 0;\n    this._rpc = void 0;\n    this._rpcCore = void 0;\n    this._runtimeChain = void 0;\n    this._runtimeMetadata = void 0;\n    this._runtimeVersion = void 0;\n    this._rx = {\n      consts: {},\n      query: {},\n      tx: {}\n    };\n    this._type = void 0;\n    this._decorateMethod = void 0;\n\n    this._rxDecorateMethod = method => {\n      return method;\n    };\n\n    _classPrivateFieldLooseBase(this, _instanceId)[_instanceId] = `${++instanceCounter}`;\n    _classPrivateFieldLooseBase(this, _registry)[_registry] = ((_options$source = options.source) === null || _options$source === void 0 ? void 0 : _options$source.registry) || options.registry || new TypeRegistry();\n\n    this._rx.queryAt = blockHash => from(this.at(blockHash)).pipe(map(a => a.rx.query));\n\n    this._rx.registry = _classPrivateFieldLooseBase(this, _registry)[_registry];\n    const thisProvider = options.source ? options.source._rpcCore.provider.clone() : options.provider || new WsProvider();\n    this._decorateMethod = decorateMethod;\n    this._options = options;\n    this._type = type; // The RPC interface decorates the known interfaces on init\n\n    this._rpcCore = new RpcCore(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], _classPrivateFieldLooseBase(this, _registry)[_registry], thisProvider, this._options.rpc);\n    this._isConnected = new BehaviorSubject(this._rpcCore.provider.isConnected);\n    this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;\n  }\n  /**\n   * @description Return the current used registry\n   */\n\n\n  get registry() {\n    return _classPrivateFieldLooseBase(this, _registry)[_registry];\n  }\n  /**\n   * @description Creates an instance of a type as registered\n   */\n\n\n  createType(type, ...params) {\n    return _classPrivateFieldLooseBase(this, _registry)[_registry].createType(type, ...params);\n  }\n  /**\n   * @description Register additional user-defined of chain-specific types in the type registry\n   */\n\n\n  registerTypes(types) {\n    types && _classPrivateFieldLooseBase(this, _registry)[_registry].register(types);\n  }\n  /**\n   * @returns `true` if the API operates with subscriptions\n   */\n\n\n  get hasSubscriptions() {\n    return this._rpcCore.provider.hasSubscriptions;\n  }\n  /**\n   * @returns `true` if the API decorate multi-key queries\n   */\n\n\n  get supportMulti() {\n    return this._rpcCore.provider.hasSubscriptions || !!this._rpcCore.state.queryStorageAt;\n  }\n\n  _createDecorated(registry, fromEmpty, blockHash, decoratedApi) {\n    if (!decoratedApi) {\n      decoratedApi = {\n        consts: {},\n        errors: {},\n        events: {},\n        query: {},\n        registry: registry.registry,\n        rx: {\n          query: {}\n        }\n      };\n    }\n\n    if (!registry.decoratedMeta) {\n      registry.decoratedMeta = expandMetadata(registry.registry, registry.metadata);\n    } // adjust the versioned registry\n\n\n    augmentObject('consts', registry.decoratedMeta.consts, decoratedApi.consts, fromEmpty);\n    augmentObject('errors', registry.decoratedMeta.errors, decoratedApi.errors, fromEmpty);\n    augmentObject('events', registry.decoratedMeta.events, decoratedApi.events, fromEmpty);\n    const storage = blockHash ? this._decorateStorageAt(registry.decoratedMeta, this._decorateMethod, blockHash) : this._decorateStorage(registry.decoratedMeta, this._decorateMethod);\n    const storageRx = blockHash ? this._decorateStorageAt(registry.decoratedMeta, this._rxDecorateMethod, blockHash) : this._decorateStorage(registry.decoratedMeta, this._rxDecorateMethod);\n    augmentObject('query', storage, decoratedApi.query, fromEmpty);\n    augmentObject('query', storageRx, decoratedApi.rx.query, fromEmpty);\n\n    decoratedApi.findCall = callIndex => findCall(registry.registry, callIndex);\n\n    decoratedApi.findError = errorIndex => findError(registry.registry, errorIndex);\n\n    decoratedApi.queryMulti = blockHash ? this._decorateMultiAt(decoratedApi, this._decorateMethod, blockHash) : this._decorateMulti(this._decorateMethod);\n    return {\n      decoratedApi,\n      decoratedMeta: registry.decoratedMeta\n    };\n  }\n\n  _injectMetadata(registry, fromEmpty) {\n    // clear the decoration, we are redoing it here\n    if (fromEmpty || !registry.decoratedApi) {\n      registry.decoratedApi = {\n        consts: {},\n        errors: {},\n        events: {},\n        query: {},\n        registry: registry.registry,\n        rx: {\n          query: {}\n        }\n      };\n    }\n\n    const {\n      decoratedApi,\n      decoratedMeta\n    } = this._createDecorated(registry, fromEmpty, null, registry.decoratedApi);\n\n    this._consts = decoratedApi.consts;\n    this._errors = decoratedApi.errors;\n    this._events = decoratedApi.events;\n    this._query = decoratedApi.query;\n    this._rx.query = decoratedApi.rx.query;\n\n    if (fromEmpty || !this._extrinsics) {\n      this._extrinsics = this._decorateExtrinsics(decoratedMeta, this._decorateMethod);\n      this._rx.tx = this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod);\n    } else {\n      augmentObject('tx', this._decorateExtrinsics(decoratedMeta, this._decorateMethod), this._extrinsics, false);\n      augmentObject(null, this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod), this._rx.tx, false);\n    }\n\n    augmentObject(null, decoratedMeta.consts, this._rx.consts, fromEmpty);\n  }\n  /**\n   * @deprecated\n   * backwards compatible endpoint for metadata injection, may be removed in the future (However, it is still useful for testing injection)\n   */\n\n\n  injectMetadata(metadata, fromEmpty, registry) {\n    this._injectMetadata({\n      metadata,\n      registry: registry || _classPrivateFieldLooseBase(this, _registry)[_registry],\n      specName: _classPrivateFieldLooseBase(this, _registry)[_registry].createType('Text'),\n      specVersion: BN_ZERO\n    }, fromEmpty);\n  }\n\n  _decorateFunctionMeta(input, output) {\n    output.meta = input.meta;\n    output.method = input.method;\n    output.section = input.section;\n    output.toJSON = input.toJSON;\n\n    if (input.callIndex) {\n      output.callIndex = input.callIndex;\n    }\n\n    return output;\n  } // Filter all RPC methods based on the results of the rpc_methods call. We do this in the following\n  // manner to cater for both old and new:\n  //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)\n  //   - when non-zero, remove anything that is not in the array (we don't do this)\n\n\n  _filterRpc(methods, additional) {\n    // add any specific user-base RPCs\n    if (Object.keys(additional).length !== 0) {\n      this._rpcCore.addUserInterfaces(additional); // re-decorate, only adding any new additional interfaces\n\n\n      this._decorateRpc(this._rpcCore, this._decorateMethod, this._rpc);\n\n      this._decorateRpc(this._rpcCore, this._rxDecorateMethod, this._rx.rpc);\n    }\n\n    this._filterRpcMethods(methods);\n  }\n\n  _filterRpcMethods(exposed) {\n    const hasResults = exposed.length !== 0;\n    const allKnown = [...this._rpcCore.mapping.entries()];\n    const allKeys = allKnown.reduce((allKeys, [, {\n      alias,\n      endpoint,\n      method,\n      pubsub,\n      section\n    }]) => {\n      allKeys.push(`${section}_${method}`);\n\n      if (pubsub) {\n        allKeys.push(`${section}_${pubsub[1]}`);\n        allKeys.push(`${section}_${pubsub[2]}`);\n      }\n\n      if (alias) {\n        allKeys.push(...alias);\n      }\n\n      if (endpoint) {\n        allKeys.push(endpoint);\n      }\n\n      return allKeys;\n    }, []);\n    const unknown = exposed.filter(k => !allKeys.includes(k));\n    const deletion = allKnown.filter(([k]) => hasResults && !exposed.includes(k) && k !== 'rpc_methods');\n\n    if (unknown.length) {\n      l.warn(`RPC methods not decorated: ${unknown.join(', ')}`);\n    } // loop through all entries we have (populated in decorate) and filter as required\n    // only remove when we have results and method missing, or with no results if optional\n\n\n    deletion.forEach(([, {\n      method,\n      section\n    }]) => {\n      delete this._rpc[section][method];\n      delete this._rx.rpc[section][method];\n    });\n  }\n\n  _decorateRpc(rpc, decorateMethod, input = {}) {\n    return rpc.sections.reduce((out, _sectionName) => {\n      const sectionName = _sectionName;\n\n      if (!out[sectionName]) {\n        // out and section here are horrors to get right from a typing perspective :(\n        out[sectionName] = Object.entries(rpc[sectionName]).reduce((section, [methodName, method]) => {\n          //  skip subscriptions where we have a non-subscribe interface\n          if (this.hasSubscriptions || !(methodName.startsWith('subscribe') || methodName.startsWith('unsubscribe'))) {\n            section[methodName] = decorateMethod(method, {\n              methodName\n            }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n            section[methodName].json = decorateMethod(method.json, {\n              methodName\n            }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n            section[methodName].raw = decorateMethod(method.raw, {\n              methodName\n            }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n            section[methodName].meta = method.meta;\n          }\n\n          return section;\n        }, {});\n      }\n\n      return out;\n    }, input);\n  } // only be called if supportMulti is true\n\n\n  _decorateMulti(decorateMethod) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorateMethod(calls => (this.hasSubscriptions ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt)(calls.map(args => Array.isArray(args) ? args[0].creator.meta.type.isPlain ? [args[0].creator] : args[0].creator.meta.type.asMap.hashers.length === 1 ? [args[0].creator, args.slice(1)] : [args[0].creator, ...args.slice(1)] : [args.creator])));\n  }\n\n  _decorateMultiAt(atApi, decorateMethod, blockHash) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorateMethod(calls => this._rpcCore.state.queryStorageAt(calls.map(args => {\n      if (Array.isArray(args)) {\n        const {\n          creator\n        } = getAtQueryFn(atApi, args[0].creator);\n        return creator.meta.type.isPlain ? [creator] : creator.meta.type.asMap.hashers.length === 1 ? [creator, args.slice(1)] : [creator, ...args.slice(1)];\n      }\n\n      return [getAtQueryFn(atApi, args.creator).creator];\n    }), blockHash));\n  }\n\n  _decorateExtrinsics({\n    tx\n  }, decorateMethod) {\n    const creator = createSubmittable(this._type, this._rx, decorateMethod);\n    return Object.entries(tx).reduce((out, [name, section]) => {\n      out[name] = Object.entries(section).reduce((out, [name, method]) => {\n        out[name] = this._decorateExtrinsicEntry(method, creator);\n        return out;\n      }, {});\n      return out;\n    }, creator);\n  }\n\n  _decorateExtrinsicEntry(method, creator) {\n    const decorated = (...params) => creator(method(...params)); // pass through the `.is`\n\n\n    decorated.is = other => method.is(other); // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n\n    return this._decorateFunctionMeta(method, decorated);\n  }\n\n  _decorateStorage({\n    query\n  }, decorateMethod) {\n    return Object.entries(query).reduce((out, [name, section]) => {\n      out[name] = Object.entries(section).reduce((out, [name, method]) => {\n        out[name] = this._decorateStorageEntry(method, decorateMethod);\n        return out;\n      }, {});\n      return out;\n    }, {});\n  }\n\n  _decorateStorageAt({\n    query,\n    registry\n  }, decorateMethod, blockHash) {\n    return Object.entries(query).reduce((out, [name, section]) => {\n      out[name] = Object.entries(section).reduce((out, [name, method]) => {\n        out[name] = this._decorateStorageEntryAt(registry, method, decorateMethod, blockHash);\n        return out;\n      }, {});\n      return out;\n    }, {});\n  }\n\n  _decorateStorageEntry(creator, decorateMethod) {\n    const getArgs = (args, registry) => extractStorageArgs(registry || _classPrivateFieldLooseBase(this, _registry)[_registry], creator, args);\n\n    const getQueryAt = blockHash => from(this.at(blockHash)).pipe(map(api => getAtQueryFn(api, creator))); // Disable this where it occurs for each field we are decorating\n\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n\n\n    const decorated = this._decorateStorageCall(creator, decorateMethod);\n\n    decorated.creator = creator;\n    decorated.at = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap(q => q(...args))));\n    decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args)));\n\n    decorated.is = key => key.section === creator.section && key.method === creator.method;\n\n    decorated.key = (...args) => u8aToHex(compactStripLength(creator(...args))[1]);\n\n    decorated.keyPrefix = (...args) => u8aToHex(creator.keyPrefix(...args));\n\n    decorated.range = decorateMethod((range, ...args) => this._decorateStorageRange(decorated, args, range));\n    decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args)));\n    decorated.sizeAt = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap(q => this._rpcCore.state.getStorageSize(getArgs(args, q.creator.meta.registry), blockHash)))); // .keys() & .entries() only available on map types\n\n    if (creator.iterKey && creator.meta.type.isMap) {\n      decorated.entries = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], (...args) => this._retrieveMapEntries(creator, null, args)));\n      decorated.entriesAt = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], (blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap(q => this._retrieveMapEntries(q.creator, blockHash, args)))));\n      decorated.entriesPaged = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], opts => this._retrieveMapEntriesPaged(creator, opts)));\n      decorated.keys = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], (...args) => this._retrieveMapKeys(creator, null, args)));\n      decorated.keysAt = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], (blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap(q => this._retrieveMapKeys(q.creator, blockHash, args)))));\n      decorated.keysPaged = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], opts => this._retrieveMapKeysPaged(creator, opts)));\n    }\n\n    if (this.supportMulti && creator.meta.type.isMap) {\n      // When using double map storage function, user need to pass double map key as an array\n      decorated.multi = decorateMethod(args => creator.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(args.map(a => [creator, [a]])) : this._retrieveMulti(args.map(a => [creator, a])));\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n\n\n    return this._decorateFunctionMeta(creator, decorated);\n  }\n\n  _decorateStorageEntryAt(registry, creator, decorateMethod, blockHash) {\n    const getArgs = args => extractStorageArgs(registry, creator, args); // Disable this where it occurs for each field we are decorating\n\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n\n\n    const decorated = decorateMethod((...args) => this._rpcCore.state.getStorage(getArgs(args), blockHash));\n    decorated.creator = creator;\n    decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args), blockHash));\n\n    decorated.is = key => key.section === creator.section && key.method === creator.method;\n\n    decorated.key = (...args) => u8aToHex(compactStripLength(creator(creator.meta.type.isPlain ? undefined : args))[1]);\n\n    decorated.keyPrefix = (...keys) => u8aToHex(creator.keyPrefix(...keys));\n\n    decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args), blockHash)); // .keys() & .entries() only available on map types\n\n    if (creator.iterKey && creator.meta.type.isMap) {\n      decorated.entries = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], (...args) => this._retrieveMapEntries(creator, blockHash, args)));\n      decorated.keys = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], (...args) => this._retrieveMapKeys(creator, blockHash, args)));\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n\n\n    return this._decorateFunctionMeta(creator, decorated);\n  } // Decorate the base storage call. In the case or rxjs or promise-without-callback (await)\n  // we make a subscription, alternatively we push this through a single-shot query\n\n\n  _decorateStorageCall(creator, decorateMethod) {\n    return decorateMethod((...args) => {\n      return this.hasSubscriptions ? this._rpcCore.state.subscribeStorage([extractStorageArgs(_classPrivateFieldLooseBase(this, _registry)[_registry], creator, args)]).pipe(map(([data]) => data) // extract first/only result from list\n      ) : this._rpcCore.state.getStorage(extractStorageArgs(_classPrivateFieldLooseBase(this, _registry)[_registry], creator, args));\n    }, {\n      methodName: creator.method,\n      overrideNoSub: (...args) => this._rpcCore.state.getStorage(extractStorageArgs(_classPrivateFieldLooseBase(this, _registry)[_registry], creator, args))\n    });\n  }\n\n  _decorateStorageRange(decorated, args, range) {\n    const outputType = unwrapStorageType(_classPrivateFieldLooseBase(this, _registry)[_registry], decorated.creator.meta.type, decorated.creator.meta.modifier.isOptional);\n    return this._rpcCore.state.queryStorage([decorated.key(...args)], ...range).pipe(map(result => result.map(([blockHash, [value]]) => [blockHash, this.createType(outputType, value.isSome ? value.unwrap().toHex() : undefined)])));\n  } // retrieve a set of values for a specific set of keys - here we chunk the keys into PAGE_SIZE sizes\n\n\n  _retrieveMulti(keys) {\n    if (!keys.length) {\n      return of([]);\n    }\n\n    const queryCall = this.hasSubscriptions ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;\n    return combineLatest(arrayChunk(keys, PAGE_SIZE_V).map(keys => queryCall(keys))).pipe(map(arrayFlatten));\n  }\n\n  _retrieveMapKeys({\n    iterKey,\n    meta,\n    method,\n    section\n  }, at, args) {\n    assert(iterKey && meta.type.isMap, 'keys can only be retrieved on maps');\n    const headKey = iterKey(...args).toHex();\n    const startSubject = new BehaviorSubject(headKey);\n    const queryCall = at ? startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey, at) : startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey);\n    return startSubject.pipe(switchMap(queryCall), map(keys => keys.map(key => key.setMeta(meta, section, method))), tap(keys => {\n      setTimeout(() => {\n        keys.length === PAGE_SIZE_K ? startSubject.next(keys[PAGE_SIZE_K - 1].toHex()) : startSubject.complete();\n      }, 0);\n    }), toArray(), // toArray since we want to startSubject to be completed\n    map(arrayFlatten));\n  }\n\n  _retrieveMapKeysPaged({\n    iterKey,\n    meta,\n    method,\n    section\n  }, opts) {\n    assert(iterKey && meta.type.isMap, 'keys can only be retrieved on maps');\n    const headKey = iterKey(...opts.args).toHex();\n    return this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey).pipe(map(keys => keys.map(key => key.setMeta(meta, section, method))));\n  }\n\n  _retrieveMapEntries(entry, at, args) {\n    const query = at ? keyset => this._rpcCore.state.queryStorageAt(keyset, at) : keyset => this._rpcCore.state.queryStorageAt(keyset);\n    return this._retrieveMapKeys(entry, at, args).pipe(switchMap(keys => keys.length ? combineLatest(arrayChunk(keys, PAGE_SIZE_V).map(query)).pipe(map(valsArr => arrayFlatten(valsArr).map((value, index) => [keys[index], value]))) : of([])));\n  }\n\n  _retrieveMapEntriesPaged(entry, opts) {\n    return this._retrieveMapKeysPaged(entry, opts).pipe(switchMap(keys => keys.length ? this._rpcCore.state.queryStorageAt(keys).pipe(map(valsArr => valsArr.map((value, index) => [keys[index], value]))) : of([])));\n  }\n\n  _decorateDeriveRx(decorateMethod) {\n    var _this$_runtimeVersion, _this$_options$typesB, _this$_options$typesB2, _this$_options$typesB3;\n\n    const specName = (_this$_runtimeVersion = this._runtimeVersion) === null || _this$_runtimeVersion === void 0 ? void 0 : _this$_runtimeVersion.specName.toString();\n\n    const derives = _objectSpread(_objectSpread({}, this._options.derives), ((_this$_options$typesB = this._options.typesBundle) === null || _this$_options$typesB === void 0 ? void 0 : (_this$_options$typesB2 = _this$_options$typesB.spec) === null || _this$_options$typesB2 === void 0 ? void 0 : (_this$_options$typesB3 = _this$_options$typesB2[specName || '']) === null || _this$_options$typesB3 === void 0 ? void 0 : _this$_options$typesB3.derives) || {}); // Pull in derive from api-derive\n\n\n    const derive = decorateDerive(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], this._rx, derives);\n    return decorateSections(derive, decorateMethod);\n  }\n\n  _decorateDerive(decorateMethod) {\n    return decorateSections(this._rx.derive, decorateMethod);\n  }\n  /**\n   * Put the `this.onCall` function of ApiRx here, because it is needed by\n   * `api._rx`.\n   */\n\n\n}","map":{"version":3,"sources":["/Users/mario/p/dapp-test/node_modules/@polkadot/api/base/Decorate.js"],"names":["_defineProperty","_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","BehaviorSubject","combineLatest","from","map","of","switchMap","tap","toArray","decorateDerive","memo","RpcCore","WsProvider","expandMetadata","TypeRegistry","unwrapStorageType","arrayChunk","arrayFlatten","assert","BN","BN_ZERO","compactStripLength","logger","u8aToHex","createSubmittable","augmentObject","decorateSections","extractStorageArgs","Events","findCall","findError","PAGE_SIZE_K","PAGE_SIZE_V","l","instanceCounter","getAtQueryFn","api","method","section","rx","query","_instanceId","_registry","Decorate","constructor","options","type","decorateMethod","_options$source","writable","value","__phantom","_consts","_derive","_errors","_events","_extrinsics","_extrinsicType","_genesisHash","_isConnected","_isReady","_options","_query","_queryMulti","_rpc","_rpcCore","_runtimeChain","_runtimeMetadata","_runtimeVersion","_rx","consts","tx","_type","_decorateMethod","_rxDecorateMethod","registry","queryAt","blockHash","at","pipe","a","thisProvider","provider","clone","rpc","isConnected","hasSubscriptions","createType","params","registerTypes","types","register","supportMulti","state","queryStorageAt","_createDecorated","fromEmpty","decoratedApi","errors","events","decoratedMeta","metadata","storage","_decorateStorageAt","_decorateStorage","storageRx","callIndex","errorIndex","queryMulti","_decorateMultiAt","_decorateMulti","_injectMetadata","_decorateExtrinsics","injectMetadata","specName","specVersion","_decorateFunctionMeta","input","output","meta","toJSON","_filterRpc","methods","additional","addUserInterfaces","_decorateRpc","_filterRpcMethods","exposed","hasResults","allKnown","mapping","entries","allKeys","reduce","alias","endpoint","pubsub","unknown","k","includes","deletion","warn","join","sections","out","_sectionName","sectionName","methodName","startsWith","json","raw","calls","subscribeStorage","args","Array","isArray","creator","isPlain","asMap","hashers","slice","atApi","name","_decorateExtrinsicEntry","decorated","is","other","_decorateStorageEntry","_decorateStorageEntryAt","getArgs","getQueryAt","_decorateStorageCall","q","hash","getStorageHash","keyPrefix","range","_decorateStorageRange","size","getStorageSize","sizeAt","iterKey","isMap","_retrieveMapEntries","entriesAt","entriesPaged","opts","_retrieveMapEntriesPaged","_retrieveMapKeys","keysAt","keysPaged","_retrieveMapKeysPaged","multi","_retrieveMulti","getStorage","undefined","data","overrideNoSub","outputType","modifier","isOptional","queryStorage","result","isSome","unwrap","toHex","queryCall","headKey","startSubject","startKey","getKeysPaged","setMeta","setTimeout","next","complete","pageSize","entry","keyset","valsArr","index","_decorateDeriveRx","_this$_runtimeVersion","_this$_options$typesB","_this$_options$typesB2","_this$_options$typesB3","toString","derives","typesBundle","spec","derive","_decorateDerive"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { BehaviorSubject, combineLatest, from, map, of, switchMap, tap, toArray } from 'rxjs';\nimport { decorateDerive } from '@polkadot/api-derive';\nimport { memo, RpcCore } from '@polkadot/rpc-core';\nimport { WsProvider } from '@polkadot/rpc-provider';\nimport { expandMetadata, TypeRegistry, unwrapStorageType } from '@polkadot/types';\nimport { arrayChunk, arrayFlatten, assert, BN, BN_ZERO, compactStripLength, logger, u8aToHex } from '@polkadot/util';\nimport { createSubmittable } from \"../submittable/index.js\";\nimport { augmentObject } from \"../util/augmentObject.js\";\nimport { decorateSections } from \"../util/decorate.js\";\nimport { extractStorageArgs } from \"../util/validate.js\";\nimport { Events } from \"./Events.js\";\nimport { findCall, findError } from \"./find.js\";\n// the max amount of keys/values that we will retrieve at once\nconst PAGE_SIZE_K = 1000; // limit aligned with the 1k on the node (trie lookups are heavy)\n\nconst PAGE_SIZE_V = 250; // limited since the data may be very large (e.g. misfiring elections)\n\nconst l = logger('api/init');\nlet instanceCounter = 0;\n\nfunction getAtQueryFn(api, {\n  method,\n  section\n}) {\n  assert(api.rx.query[section] && api.rx.query[section][method], () => `query.${section}.${method} is not available in this version of the metadata`);\n  return api.rx.query[section][method];\n}\n\nvar _instanceId = /*#__PURE__*/_classPrivateFieldLooseKey(\"instanceId\");\n\nvar _registry = /*#__PURE__*/_classPrivateFieldLooseKey(\"registry\");\n\nexport class Decorate extends Events {\n  // HACK Use BN import so decorateDerive works... yes, wtf.\n  // latest extrinsic version\n\n  /**\n   * This is the one and only method concrete children classes need to implement.\n   * It's a higher-order function, which takes one argument\n   * `method: Method extends (...args: any[]) => Observable<any>`\n   * (and one optional `options`), and should return the user facing method.\n   * For example:\n   * - For ApiRx, `decorateMethod` should just be identity, because the input\n   * function is already an Observable\n   * - For ApiPromise, `decorateMethod` should return a function that takes all\n   * the parameters from `method`, adds an optional `callback` argument, and\n   * returns a Promise.\n   *\n   * We could easily imagine other user-facing interfaces, which are simply\n   * implemented by transforming the Observable to Stream/Iterator/Kefir/Bacon\n   * via `decorateMethod`.\n   */\n\n  /**\n   * @description Create an instance of the class\n   *\n   * @param options Options object to create API instance or a Provider instance\n   *\n   * @example\n   * <BR>\n   *\n   * ```javascript\n   * import Api from '@polkadot/api/promise';\n   *\n   * const api = new Api().isReady();\n   *\n   * api.rpc.subscribeNewHeads((header) => {\n   *   console.log(`new block #${header.number.toNumber()}`);\n   * });\n   * ```\n   */\n  constructor(options, type, decorateMethod) {\n    var _options$source;\n\n    super();\n    Object.defineProperty(this, _instanceId, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _registry, {\n      writable: true,\n      value: void 0\n    });\n    this.__phantom = new BN(0);\n    this._consts = {};\n    this._derive = void 0;\n    this._errors = {};\n    this._events = {};\n    this._extrinsics = void 0;\n    this._extrinsicType = 4;\n    this._genesisHash = void 0;\n    this._isConnected = void 0;\n    this._isReady = false;\n    this._options = void 0;\n    this._query = {};\n    this._queryMulti = void 0;\n    this._rpc = void 0;\n    this._rpcCore = void 0;\n    this._runtimeChain = void 0;\n    this._runtimeMetadata = void 0;\n    this._runtimeVersion = void 0;\n    this._rx = {\n      consts: {},\n      query: {},\n      tx: {}\n    };\n    this._type = void 0;\n    this._decorateMethod = void 0;\n\n    this._rxDecorateMethod = method => {\n      return method;\n    };\n\n    _classPrivateFieldLooseBase(this, _instanceId)[_instanceId] = `${++instanceCounter}`;\n    _classPrivateFieldLooseBase(this, _registry)[_registry] = ((_options$source = options.source) === null || _options$source === void 0 ? void 0 : _options$source.registry) || options.registry || new TypeRegistry();\n\n    this._rx.queryAt = blockHash => from(this.at(blockHash)).pipe(map(a => a.rx.query));\n\n    this._rx.registry = _classPrivateFieldLooseBase(this, _registry)[_registry];\n    const thisProvider = options.source ? options.source._rpcCore.provider.clone() : options.provider || new WsProvider();\n    this._decorateMethod = decorateMethod;\n    this._options = options;\n    this._type = type; // The RPC interface decorates the known interfaces on init\n\n    this._rpcCore = new RpcCore(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], _classPrivateFieldLooseBase(this, _registry)[_registry], thisProvider, this._options.rpc);\n    this._isConnected = new BehaviorSubject(this._rpcCore.provider.isConnected);\n    this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;\n  }\n\n  /**\n   * @description Return the current used registry\n   */\n  get registry() {\n    return _classPrivateFieldLooseBase(this, _registry)[_registry];\n  }\n  /**\n   * @description Creates an instance of a type as registered\n   */\n\n\n  createType(type, ...params) {\n    return _classPrivateFieldLooseBase(this, _registry)[_registry].createType(type, ...params);\n  }\n  /**\n   * @description Register additional user-defined of chain-specific types in the type registry\n   */\n\n\n  registerTypes(types) {\n    types && _classPrivateFieldLooseBase(this, _registry)[_registry].register(types);\n  }\n  /**\n   * @returns `true` if the API operates with subscriptions\n   */\n\n\n  get hasSubscriptions() {\n    return this._rpcCore.provider.hasSubscriptions;\n  }\n  /**\n   * @returns `true` if the API decorate multi-key queries\n   */\n\n\n  get supportMulti() {\n    return this._rpcCore.provider.hasSubscriptions || !!this._rpcCore.state.queryStorageAt;\n  }\n\n  _createDecorated(registry, fromEmpty, blockHash, decoratedApi) {\n    if (!decoratedApi) {\n      decoratedApi = {\n        consts: {},\n        errors: {},\n        events: {},\n        query: {},\n        registry: registry.registry,\n        rx: {\n          query: {}\n        }\n      };\n    }\n\n    if (!registry.decoratedMeta) {\n      registry.decoratedMeta = expandMetadata(registry.registry, registry.metadata);\n    } // adjust the versioned registry\n\n\n    augmentObject('consts', registry.decoratedMeta.consts, decoratedApi.consts, fromEmpty);\n    augmentObject('errors', registry.decoratedMeta.errors, decoratedApi.errors, fromEmpty);\n    augmentObject('events', registry.decoratedMeta.events, decoratedApi.events, fromEmpty);\n    const storage = blockHash ? this._decorateStorageAt(registry.decoratedMeta, this._decorateMethod, blockHash) : this._decorateStorage(registry.decoratedMeta, this._decorateMethod);\n    const storageRx = blockHash ? this._decorateStorageAt(registry.decoratedMeta, this._rxDecorateMethod, blockHash) : this._decorateStorage(registry.decoratedMeta, this._rxDecorateMethod);\n    augmentObject('query', storage, decoratedApi.query, fromEmpty);\n    augmentObject('query', storageRx, decoratedApi.rx.query, fromEmpty);\n\n    decoratedApi.findCall = callIndex => findCall(registry.registry, callIndex);\n\n    decoratedApi.findError = errorIndex => findError(registry.registry, errorIndex);\n\n    decoratedApi.queryMulti = blockHash ? this._decorateMultiAt(decoratedApi, this._decorateMethod, blockHash) : this._decorateMulti(this._decorateMethod);\n    return {\n      decoratedApi,\n      decoratedMeta: registry.decoratedMeta\n    };\n  }\n\n  _injectMetadata(registry, fromEmpty) {\n    // clear the decoration, we are redoing it here\n    if (fromEmpty || !registry.decoratedApi) {\n      registry.decoratedApi = {\n        consts: {},\n        errors: {},\n        events: {},\n        query: {},\n        registry: registry.registry,\n        rx: {\n          query: {}\n        }\n      };\n    }\n\n    const {\n      decoratedApi,\n      decoratedMeta\n    } = this._createDecorated(registry, fromEmpty, null, registry.decoratedApi);\n\n    this._consts = decoratedApi.consts;\n    this._errors = decoratedApi.errors;\n    this._events = decoratedApi.events;\n    this._query = decoratedApi.query;\n    this._rx.query = decoratedApi.rx.query;\n\n    if (fromEmpty || !this._extrinsics) {\n      this._extrinsics = this._decorateExtrinsics(decoratedMeta, this._decorateMethod);\n      this._rx.tx = this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod);\n    } else {\n      augmentObject('tx', this._decorateExtrinsics(decoratedMeta, this._decorateMethod), this._extrinsics, false);\n      augmentObject(null, this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod), this._rx.tx, false);\n    }\n\n    augmentObject(null, decoratedMeta.consts, this._rx.consts, fromEmpty);\n  }\n  /**\n   * @deprecated\n   * backwards compatible endpoint for metadata injection, may be removed in the future (However, it is still useful for testing injection)\n   */\n\n\n  injectMetadata(metadata, fromEmpty, registry) {\n    this._injectMetadata({\n      metadata,\n      registry: registry || _classPrivateFieldLooseBase(this, _registry)[_registry],\n      specName: _classPrivateFieldLooseBase(this, _registry)[_registry].createType('Text'),\n      specVersion: BN_ZERO\n    }, fromEmpty);\n  }\n\n  _decorateFunctionMeta(input, output) {\n    output.meta = input.meta;\n    output.method = input.method;\n    output.section = input.section;\n    output.toJSON = input.toJSON;\n\n    if (input.callIndex) {\n      output.callIndex = input.callIndex;\n    }\n\n    return output;\n  } // Filter all RPC methods based on the results of the rpc_methods call. We do this in the following\n  // manner to cater for both old and new:\n  //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)\n  //   - when non-zero, remove anything that is not in the array (we don't do this)\n\n\n  _filterRpc(methods, additional) {\n    // add any specific user-base RPCs\n    if (Object.keys(additional).length !== 0) {\n      this._rpcCore.addUserInterfaces(additional); // re-decorate, only adding any new additional interfaces\n\n\n      this._decorateRpc(this._rpcCore, this._decorateMethod, this._rpc);\n\n      this._decorateRpc(this._rpcCore, this._rxDecorateMethod, this._rx.rpc);\n    }\n\n    this._filterRpcMethods(methods);\n  }\n\n  _filterRpcMethods(exposed) {\n    const hasResults = exposed.length !== 0;\n    const allKnown = [...this._rpcCore.mapping.entries()];\n    const allKeys = allKnown.reduce((allKeys, [, {\n      alias,\n      endpoint,\n      method,\n      pubsub,\n      section\n    }]) => {\n      allKeys.push(`${section}_${method}`);\n\n      if (pubsub) {\n        allKeys.push(`${section}_${pubsub[1]}`);\n        allKeys.push(`${section}_${pubsub[2]}`);\n      }\n\n      if (alias) {\n        allKeys.push(...alias);\n      }\n\n      if (endpoint) {\n        allKeys.push(endpoint);\n      }\n\n      return allKeys;\n    }, []);\n    const unknown = exposed.filter(k => !allKeys.includes(k));\n    const deletion = allKnown.filter(([k]) => hasResults && !exposed.includes(k) && k !== 'rpc_methods');\n\n    if (unknown.length) {\n      l.warn(`RPC methods not decorated: ${unknown.join(', ')}`);\n    } // loop through all entries we have (populated in decorate) and filter as required\n    // only remove when we have results and method missing, or with no results if optional\n\n\n    deletion.forEach(([, {\n      method,\n      section\n    }]) => {\n      delete this._rpc[section][method];\n      delete this._rx.rpc[section][method];\n    });\n  }\n\n  _decorateRpc(rpc, decorateMethod, input = {}) {\n    return rpc.sections.reduce((out, _sectionName) => {\n      const sectionName = _sectionName;\n\n      if (!out[sectionName]) {\n        // out and section here are horrors to get right from a typing perspective :(\n        out[sectionName] = Object.entries(rpc[sectionName]).reduce((section, [methodName, method]) => {\n          //  skip subscriptions where we have a non-subscribe interface\n          if (this.hasSubscriptions || !(methodName.startsWith('subscribe') || methodName.startsWith('unsubscribe'))) {\n            section[methodName] = decorateMethod(method, {\n              methodName\n            }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n            section[methodName].json = decorateMethod(method.json, {\n              methodName\n            }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n            section[methodName].raw = decorateMethod(method.raw, {\n              methodName\n            }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n            section[methodName].meta = method.meta;\n          }\n\n          return section;\n        }, {});\n      }\n\n      return out;\n    }, input);\n  } // only be called if supportMulti is true\n\n\n  _decorateMulti(decorateMethod) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorateMethod(calls => (this.hasSubscriptions ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt)(calls.map(args => Array.isArray(args) ? args[0].creator.meta.type.isPlain ? [args[0].creator] : args[0].creator.meta.type.asMap.hashers.length === 1 ? [args[0].creator, args.slice(1)] : [args[0].creator, ...args.slice(1)] : [args.creator])));\n  }\n\n  _decorateMultiAt(atApi, decorateMethod, blockHash) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return decorateMethod(calls => this._rpcCore.state.queryStorageAt(calls.map(args => {\n      if (Array.isArray(args)) {\n        const {\n          creator\n        } = getAtQueryFn(atApi, args[0].creator);\n        return creator.meta.type.isPlain ? [creator] : creator.meta.type.asMap.hashers.length === 1 ? [creator, args.slice(1)] : [creator, ...args.slice(1)];\n      }\n\n      return [getAtQueryFn(atApi, args.creator).creator];\n    }), blockHash));\n  }\n\n  _decorateExtrinsics({\n    tx\n  }, decorateMethod) {\n    const creator = createSubmittable(this._type, this._rx, decorateMethod);\n    return Object.entries(tx).reduce((out, [name, section]) => {\n      out[name] = Object.entries(section).reduce((out, [name, method]) => {\n        out[name] = this._decorateExtrinsicEntry(method, creator);\n        return out;\n      }, {});\n      return out;\n    }, creator);\n  }\n\n  _decorateExtrinsicEntry(method, creator) {\n    const decorated = (...params) => creator(method(...params)); // pass through the `.is`\n\n\n    decorated.is = other => method.is(other); // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n\n    return this._decorateFunctionMeta(method, decorated);\n  }\n\n  _decorateStorage({\n    query\n  }, decorateMethod) {\n    return Object.entries(query).reduce((out, [name, section]) => {\n      out[name] = Object.entries(section).reduce((out, [name, method]) => {\n        out[name] = this._decorateStorageEntry(method, decorateMethod);\n        return out;\n      }, {});\n      return out;\n    }, {});\n  }\n\n  _decorateStorageAt({\n    query,\n    registry\n  }, decorateMethod, blockHash) {\n    return Object.entries(query).reduce((out, [name, section]) => {\n      out[name] = Object.entries(section).reduce((out, [name, method]) => {\n        out[name] = this._decorateStorageEntryAt(registry, method, decorateMethod, blockHash);\n        return out;\n      }, {});\n      return out;\n    }, {});\n  }\n\n  _decorateStorageEntry(creator, decorateMethod) {\n    const getArgs = (args, registry) => extractStorageArgs(registry || _classPrivateFieldLooseBase(this, _registry)[_registry], creator, args);\n\n    const getQueryAt = blockHash => from(this.at(blockHash)).pipe(map(api => getAtQueryFn(api, creator))); // Disable this where it occurs for each field we are decorating\n\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n\n\n    const decorated = this._decorateStorageCall(creator, decorateMethod);\n\n    decorated.creator = creator;\n    decorated.at = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap(q => q(...args))));\n    decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args)));\n\n    decorated.is = key => key.section === creator.section && key.method === creator.method;\n\n    decorated.key = (...args) => u8aToHex(compactStripLength(creator(...args))[1]);\n\n    decorated.keyPrefix = (...args) => u8aToHex(creator.keyPrefix(...args));\n\n    decorated.range = decorateMethod((range, ...args) => this._decorateStorageRange(decorated, args, range));\n    decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args)));\n    decorated.sizeAt = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap(q => this._rpcCore.state.getStorageSize(getArgs(args, q.creator.meta.registry), blockHash)))); // .keys() & .entries() only available on map types\n\n    if (creator.iterKey && creator.meta.type.isMap) {\n      decorated.entries = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], (...args) => this._retrieveMapEntries(creator, null, args)));\n      decorated.entriesAt = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], (blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap(q => this._retrieveMapEntries(q.creator, blockHash, args)))));\n      decorated.entriesPaged = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], opts => this._retrieveMapEntriesPaged(creator, opts)));\n      decorated.keys = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], (...args) => this._retrieveMapKeys(creator, null, args)));\n      decorated.keysAt = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], (blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap(q => this._retrieveMapKeys(q.creator, blockHash, args)))));\n      decorated.keysPaged = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], opts => this._retrieveMapKeysPaged(creator, opts)));\n    }\n\n    if (this.supportMulti && creator.meta.type.isMap) {\n      // When using double map storage function, user need to pass double map key as an array\n      decorated.multi = decorateMethod(args => creator.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(args.map(a => [creator, [a]])) : this._retrieveMulti(args.map(a => [creator, a])));\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n\n\n    return this._decorateFunctionMeta(creator, decorated);\n  }\n\n  _decorateStorageEntryAt(registry, creator, decorateMethod, blockHash) {\n    const getArgs = args => extractStorageArgs(registry, creator, args); // Disable this where it occurs for each field we are decorating\n\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n\n\n    const decorated = decorateMethod((...args) => this._rpcCore.state.getStorage(getArgs(args), blockHash));\n    decorated.creator = creator;\n    decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args), blockHash));\n\n    decorated.is = key => key.section === creator.section && key.method === creator.method;\n\n    decorated.key = (...args) => u8aToHex(compactStripLength(creator(creator.meta.type.isPlain ? undefined : args))[1]);\n\n    decorated.keyPrefix = (...keys) => u8aToHex(creator.keyPrefix(...keys));\n\n    decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args), blockHash)); // .keys() & .entries() only available on map types\n\n    if (creator.iterKey && creator.meta.type.isMap) {\n      decorated.entries = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], (...args) => this._retrieveMapEntries(creator, blockHash, args)));\n      decorated.keys = decorateMethod(memo(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], (...args) => this._retrieveMapKeys(creator, blockHash, args)));\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n\n\n    return this._decorateFunctionMeta(creator, decorated);\n  } // Decorate the base storage call. In the case or rxjs or promise-without-callback (await)\n  // we make a subscription, alternatively we push this through a single-shot query\n\n\n  _decorateStorageCall(creator, decorateMethod) {\n    return decorateMethod((...args) => {\n      return this.hasSubscriptions ? this._rpcCore.state.subscribeStorage([extractStorageArgs(_classPrivateFieldLooseBase(this, _registry)[_registry], creator, args)]).pipe(map(([data]) => data) // extract first/only result from list\n      ) : this._rpcCore.state.getStorage(extractStorageArgs(_classPrivateFieldLooseBase(this, _registry)[_registry], creator, args));\n    }, {\n      methodName: creator.method,\n      overrideNoSub: (...args) => this._rpcCore.state.getStorage(extractStorageArgs(_classPrivateFieldLooseBase(this, _registry)[_registry], creator, args))\n    });\n  }\n\n  _decorateStorageRange(decorated, args, range) {\n    const outputType = unwrapStorageType(_classPrivateFieldLooseBase(this, _registry)[_registry], decorated.creator.meta.type, decorated.creator.meta.modifier.isOptional);\n    return this._rpcCore.state.queryStorage([decorated.key(...args)], ...range).pipe(map(result => result.map(([blockHash, [value]]) => [blockHash, this.createType(outputType, value.isSome ? value.unwrap().toHex() : undefined)])));\n  } // retrieve a set of values for a specific set of keys - here we chunk the keys into PAGE_SIZE sizes\n\n\n  _retrieveMulti(keys) {\n    if (!keys.length) {\n      return of([]);\n    }\n\n    const queryCall = this.hasSubscriptions ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;\n    return combineLatest(arrayChunk(keys, PAGE_SIZE_V).map(keys => queryCall(keys))).pipe(map(arrayFlatten));\n  }\n\n  _retrieveMapKeys({\n    iterKey,\n    meta,\n    method,\n    section\n  }, at, args) {\n    assert(iterKey && meta.type.isMap, 'keys can only be retrieved on maps');\n    const headKey = iterKey(...args).toHex();\n    const startSubject = new BehaviorSubject(headKey);\n    const queryCall = at ? startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey, at) : startKey => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey);\n    return startSubject.pipe(switchMap(queryCall), map(keys => keys.map(key => key.setMeta(meta, section, method))), tap(keys => {\n      setTimeout(() => {\n        keys.length === PAGE_SIZE_K ? startSubject.next(keys[PAGE_SIZE_K - 1].toHex()) : startSubject.complete();\n      }, 0);\n    }), toArray(), // toArray since we want to startSubject to be completed\n    map(arrayFlatten));\n  }\n\n  _retrieveMapKeysPaged({\n    iterKey,\n    meta,\n    method,\n    section\n  }, opts) {\n    assert(iterKey && meta.type.isMap, 'keys can only be retrieved on maps');\n    const headKey = iterKey(...opts.args).toHex();\n    return this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey).pipe(map(keys => keys.map(key => key.setMeta(meta, section, method))));\n  }\n\n  _retrieveMapEntries(entry, at, args) {\n    const query = at ? keyset => this._rpcCore.state.queryStorageAt(keyset, at) : keyset => this._rpcCore.state.queryStorageAt(keyset);\n    return this._retrieveMapKeys(entry, at, args).pipe(switchMap(keys => keys.length ? combineLatest(arrayChunk(keys, PAGE_SIZE_V).map(query)).pipe(map(valsArr => arrayFlatten(valsArr).map((value, index) => [keys[index], value]))) : of([])));\n  }\n\n  _retrieveMapEntriesPaged(entry, opts) {\n    return this._retrieveMapKeysPaged(entry, opts).pipe(switchMap(keys => keys.length ? this._rpcCore.state.queryStorageAt(keys).pipe(map(valsArr => valsArr.map((value, index) => [keys[index], value]))) : of([])));\n  }\n\n  _decorateDeriveRx(decorateMethod) {\n    var _this$_runtimeVersion, _this$_options$typesB, _this$_options$typesB2, _this$_options$typesB3;\n\n    const specName = (_this$_runtimeVersion = this._runtimeVersion) === null || _this$_runtimeVersion === void 0 ? void 0 : _this$_runtimeVersion.specName.toString();\n\n    const derives = _objectSpread(_objectSpread({}, this._options.derives), ((_this$_options$typesB = this._options.typesBundle) === null || _this$_options$typesB === void 0 ? void 0 : (_this$_options$typesB2 = _this$_options$typesB.spec) === null || _this$_options$typesB2 === void 0 ? void 0 : (_this$_options$typesB3 = _this$_options$typesB2[specName || '']) === null || _this$_options$typesB3 === void 0 ? void 0 : _this$_options$typesB3.derives) || {}); // Pull in derive from api-derive\n\n\n    const derive = decorateDerive(_classPrivateFieldLooseBase(this, _instanceId)[_instanceId], this._rx, derives);\n    return decorateSections(derive, decorateMethod);\n  }\n\n  _decorateDerive(decorateMethod) {\n    return decorateSections(this._rx.derive, decorateMethod);\n  }\n  /**\n   * Put the `this.onCall` function of ApiRx here, because it is needed by\n   * `api._rx`.\n   */\n\n\n}"]},"metadata":{},"sourceType":"module"}