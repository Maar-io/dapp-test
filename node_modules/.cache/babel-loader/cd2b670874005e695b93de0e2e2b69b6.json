{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, isNumber, isUndefined, stringify } from '@polkadot/util';\nimport { TypeDefInfo } from \"./types.js\";\n\nconst stringIdentity = value => value.toString();\n\nconst INFO_WRAP = ['BTreeMap', 'BTreeSet', 'Compact', 'HashMap', 'Option', 'Result', 'Vec'];\nexport function paramsNotation(outer, inner, transform = stringIdentity) {\n  return `${outer}${inner ? `<${(Array.isArray(inner) ? inner : [inner]).map(transform).join(', ')}>` : ''}`;\n}\n\nfunction encodeWithParams(registry, typeDef, outer) {\n  const {\n    info,\n    sub\n  } = typeDef;\n\n  switch (info) {\n    case TypeDefInfo.BTreeMap:\n    case TypeDefInfo.BTreeSet:\n    case TypeDefInfo.Compact:\n    case TypeDefInfo.HashMap:\n    case TypeDefInfo.Linkage:\n    case TypeDefInfo.Option:\n    case TypeDefInfo.Result:\n    case TypeDefInfo.Vec:\n    case TypeDefInfo.WrapperOpaque:\n      return paramsNotation(outer, sub, p => encodeTypeDef(registry, p));\n  }\n\n  throw new Error(`Unable to encode ${stringify(typeDef)} with params`);\n}\n\nfunction encodeSubTypes(registry, sub, asEnum, extra) {\n  const names = sub.map(({\n    name\n  }) => name);\n  assert(names.every(n => !!n), () => `Subtypes does not have consistent names, ${names.join(', ')}`);\n  const inner = sub.reduce((result, type) => _objectSpread(_objectSpread({}, result), {}, {\n    [type.name]: encodeTypeDef(registry, type)\n  }), _objectSpread({}, extra));\n  return stringify(asEnum ? {\n    _enum: inner\n  } : inner);\n} // We setup a record here to ensure we have comprehensive coverage (any item not covered will result\n// in a compile-time error with the missing index)\n\n\nconst encoders = {\n  [TypeDefInfo.BTreeMap]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'BTreeMap'),\n  [TypeDefInfo.BTreeSet]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'BTreeSet'),\n  [TypeDefInfo.Compact]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Compact'),\n  [TypeDefInfo.DoNotConstruct]: (registry, {\n    displayName,\n    lookupIndex,\n    lookupName\n  }) => `DoNotConstruct<${lookupName || displayName || (isUndefined(lookupIndex) ? 'Unknown' : registry.createLookupType(lookupIndex))}>`,\n  [TypeDefInfo.Enum]: (registry, {\n    sub\n  }) => {\n    assert(sub && Array.isArray(sub), 'Unable to encode Enum type'); // c-like enums have all Null entries\n    // TODO We need to take the disciminant into account and auto-add empty entries\n\n    return sub.every(({\n      type\n    }) => type === 'Null') ? stringify({\n      _enum: sub.map(({\n        name\n      }, index) => `${name || `Empty${index}`}`)\n    }) : encodeSubTypes(registry, sub, true);\n  },\n  [TypeDefInfo.HashMap]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'HashMap'),\n  [TypeDefInfo.Int]: (registry, {\n    length = 32\n  }) => `Int<${length}>`,\n  [TypeDefInfo.Linkage]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Linkage'),\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [TypeDefInfo.Null]: (registry, typeDef) => 'Null',\n  [TypeDefInfo.Option]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Option'),\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [TypeDefInfo.Plain]: (registry, {\n    displayName,\n    type\n  }) => displayName || type,\n  [TypeDefInfo.Range]: (registry, typeDef) => encodeWithParams(registry, typeDef, typeDef.type.includes('RangeInclusive') ? 'RangeInclusive' : 'Range'),\n  [TypeDefInfo.Result]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Result'),\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [TypeDefInfo.Set]: (registry, {\n    length = 8,\n    sub\n  }) => {\n    assert(sub && Array.isArray(sub), 'Unable to encode Set type');\n    return stringify({\n      _set: sub.reduce((all, {\n        index,\n        name\n      }, count) => _objectSpread(_objectSpread({}, all), {}, {\n        [`${name || `Unknown${index || count}`}`]: index || count\n      }), {\n        _bitLength: length || 8\n      })\n    });\n  },\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [TypeDefInfo.Si]: (registry, {\n    lookupName,\n    type\n  }) => lookupName || type,\n  [TypeDefInfo.Struct]: (registry, {\n    alias,\n    sub\n  }) => {\n    assert(sub && Array.isArray(sub), 'Unable to encode Struct type');\n    return encodeSubTypes(registry, sub, false, _objectSpread({}, alias ? {\n      _alias: [...alias.entries()].reduce((all, [k, v]) => _objectSpread(_objectSpread({}, all), {}, {\n        [k]: v\n      }), {})\n    } : {}));\n  },\n  [TypeDefInfo.Tuple]: (registry, {\n    sub\n  }) => {\n    assert(sub && Array.isArray(sub), 'Unable to encode Tuple type');\n    return `(${sub.map(type => encodeTypeDef(registry, type)).join(',')})`;\n  },\n  [TypeDefInfo.UInt]: (registry, {\n    length = 32\n  }) => `UInt<${length}>`,\n  [TypeDefInfo.Vec]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Vec'),\n  [TypeDefInfo.VecFixed]: (registry, {\n    length,\n    sub\n  }) => {\n    assert(isNumber(length) && !isUndefined(sub) && !Array.isArray(sub), 'Unable to encode VecFixed type');\n    return `[${sub.type};${length}]`;\n  },\n  [TypeDefInfo.WrapperOpaque]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'WrapperOpaque')\n};\n\nfunction encodeType(registry, typeDef, withLookup = true) {\n  return withLookup && typeDef.lookupName ? typeDef.lookupName : encoders[typeDef.info](registry, typeDef);\n}\n\nexport function encodeTypeDef(registry, typeDef) {\n  // In the case of contracts we do have the unfortunate situation where the displayName would\n  // refer to \"Option\" when it is an option. For these, string it out, only using when actually\n  // not a top-level element to be used\n  return typeDef.displayName && !INFO_WRAP.some(i => typeDef.displayName === i) ? typeDef.displayName : encodeType(registry, typeDef);\n}\nexport function withTypeString(registry, typeDef) {\n  return _objectSpread(_objectSpread({}, typeDef), {}, {\n    type: encodeType(registry, typeDef, false)\n  });\n}","map":{"version":3,"sources":["/Users/mario/p/dapp-test/node_modules/@polkadot/types/create/encodeTypes.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","assert","isNumber","isUndefined","stringify","TypeDefInfo","stringIdentity","value","toString","INFO_WRAP","paramsNotation","outer","inner","transform","Array","isArray","map","join","encodeWithParams","registry","typeDef","info","sub","BTreeMap","BTreeSet","Compact","HashMap","Linkage","Option","Result","Vec","WrapperOpaque","p","encodeTypeDef","Error","encodeSubTypes","asEnum","extra","names","name","every","n","reduce","result","type","_enum","encoders","DoNotConstruct","displayName","lookupIndex","lookupName","createLookupType","Enum","index","Int","Null","Plain","Range","includes","Set","_set","all","count","_bitLength","Si","Struct","alias","_alias","entries","k","v","Tuple","UInt","VecFixed","encodeType","withLookup","some","withTypeString"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isNumber, isUndefined, stringify } from '@polkadot/util';\nimport { TypeDefInfo } from \"./types.js\";\n\nconst stringIdentity = value => value.toString();\n\nconst INFO_WRAP = ['BTreeMap', 'BTreeSet', 'Compact', 'HashMap', 'Option', 'Result', 'Vec'];\nexport function paramsNotation(outer, inner, transform = stringIdentity) {\n  return `${outer}${inner ? `<${(Array.isArray(inner) ? inner : [inner]).map(transform).join(', ')}>` : ''}`;\n}\n\nfunction encodeWithParams(registry, typeDef, outer) {\n  const {\n    info,\n    sub\n  } = typeDef;\n\n  switch (info) {\n    case TypeDefInfo.BTreeMap:\n    case TypeDefInfo.BTreeSet:\n    case TypeDefInfo.Compact:\n    case TypeDefInfo.HashMap:\n    case TypeDefInfo.Linkage:\n    case TypeDefInfo.Option:\n    case TypeDefInfo.Result:\n    case TypeDefInfo.Vec:\n    case TypeDefInfo.WrapperOpaque:\n      return paramsNotation(outer, sub, p => encodeTypeDef(registry, p));\n  }\n\n  throw new Error(`Unable to encode ${stringify(typeDef)} with params`);\n}\n\nfunction encodeSubTypes(registry, sub, asEnum, extra) {\n  const names = sub.map(({\n    name\n  }) => name);\n  assert(names.every(n => !!n), () => `Subtypes does not have consistent names, ${names.join(', ')}`);\n  const inner = sub.reduce((result, type) => _objectSpread(_objectSpread({}, result), {}, {\n    [type.name]: encodeTypeDef(registry, type)\n  }), _objectSpread({}, extra));\n  return stringify(asEnum ? {\n    _enum: inner\n  } : inner);\n} // We setup a record here to ensure we have comprehensive coverage (any item not covered will result\n// in a compile-time error with the missing index)\n\n\nconst encoders = {\n  [TypeDefInfo.BTreeMap]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'BTreeMap'),\n  [TypeDefInfo.BTreeSet]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'BTreeSet'),\n  [TypeDefInfo.Compact]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Compact'),\n  [TypeDefInfo.DoNotConstruct]: (registry, {\n    displayName,\n    lookupIndex,\n    lookupName\n  }) => `DoNotConstruct<${lookupName || displayName || (isUndefined(lookupIndex) ? 'Unknown' : registry.createLookupType(lookupIndex))}>`,\n  [TypeDefInfo.Enum]: (registry, {\n    sub\n  }) => {\n    assert(sub && Array.isArray(sub), 'Unable to encode Enum type'); // c-like enums have all Null entries\n    // TODO We need to take the disciminant into account and auto-add empty entries\n\n    return sub.every(({\n      type\n    }) => type === 'Null') ? stringify({\n      _enum: sub.map(({\n        name\n      }, index) => `${name || `Empty${index}`}`)\n    }) : encodeSubTypes(registry, sub, true);\n  },\n  [TypeDefInfo.HashMap]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'HashMap'),\n  [TypeDefInfo.Int]: (registry, {\n    length = 32\n  }) => `Int<${length}>`,\n  [TypeDefInfo.Linkage]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Linkage'),\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [TypeDefInfo.Null]: (registry, typeDef) => 'Null',\n  [TypeDefInfo.Option]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Option'),\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [TypeDefInfo.Plain]: (registry, {\n    displayName,\n    type\n  }) => displayName || type,\n  [TypeDefInfo.Range]: (registry, typeDef) => encodeWithParams(registry, typeDef, typeDef.type.includes('RangeInclusive') ? 'RangeInclusive' : 'Range'),\n  [TypeDefInfo.Result]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Result'),\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [TypeDefInfo.Set]: (registry, {\n    length = 8,\n    sub\n  }) => {\n    assert(sub && Array.isArray(sub), 'Unable to encode Set type');\n    return stringify({\n      _set: sub.reduce((all, {\n        index,\n        name\n      }, count) => _objectSpread(_objectSpread({}, all), {}, {\n        [`${name || `Unknown${index || count}`}`]: index || count\n      }), {\n        _bitLength: length || 8\n      })\n    });\n  },\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [TypeDefInfo.Si]: (registry, {\n    lookupName,\n    type\n  }) => lookupName || type,\n  [TypeDefInfo.Struct]: (registry, {\n    alias,\n    sub\n  }) => {\n    assert(sub && Array.isArray(sub), 'Unable to encode Struct type');\n    return encodeSubTypes(registry, sub, false, _objectSpread({}, alias ? {\n      _alias: [...alias.entries()].reduce((all, [k, v]) => _objectSpread(_objectSpread({}, all), {}, {\n        [k]: v\n      }), {})\n    } : {}));\n  },\n  [TypeDefInfo.Tuple]: (registry, {\n    sub\n  }) => {\n    assert(sub && Array.isArray(sub), 'Unable to encode Tuple type');\n    return `(${sub.map(type => encodeTypeDef(registry, type)).join(',')})`;\n  },\n  [TypeDefInfo.UInt]: (registry, {\n    length = 32\n  }) => `UInt<${length}>`,\n  [TypeDefInfo.Vec]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Vec'),\n  [TypeDefInfo.VecFixed]: (registry, {\n    length,\n    sub\n  }) => {\n    assert(isNumber(length) && !isUndefined(sub) && !Array.isArray(sub), 'Unable to encode VecFixed type');\n    return `[${sub.type};${length}]`;\n  },\n  [TypeDefInfo.WrapperOpaque]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'WrapperOpaque')\n};\n\nfunction encodeType(registry, typeDef, withLookup = true) {\n  return withLookup && typeDef.lookupName ? typeDef.lookupName : encoders[typeDef.info](registry, typeDef);\n}\n\nexport function encodeTypeDef(registry, typeDef) {\n  // In the case of contracts we do have the unfortunate situation where the displayName would\n  // refer to \"Option\" when it is an option. For these, string it out, only using when actually\n  // not a top-level element to be used\n  return typeDef.displayName && !INFO_WRAP.some(i => typeDef.displayName === i) ? typeDef.displayName : encodeType(registry, typeDef);\n}\nexport function withTypeString(registry, typeDef) {\n  return _objectSpread(_objectSpread({}, typeDef), {}, {\n    type: encodeType(registry, typeDef, false)\n  });\n}"]},"metadata":{},"sourceType":"module"}