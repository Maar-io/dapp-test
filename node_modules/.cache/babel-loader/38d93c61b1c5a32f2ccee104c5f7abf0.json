{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nfunction convertArray(registry, {\n  len,\n  type\n}) {\n  return registry.createType('Si1TypeDef', {\n    Array: {\n      len,\n      type: type.toNumber()\n    }\n  });\n}\n\nfunction convertBitSequence(registry, {\n  bitOrderType,\n  bitStoreType\n}) {\n  return registry.createType('Si1TypeDef', {\n    BitSequence: {\n      bitOrderType: bitOrderType.toNumber(),\n      bitStoreType: bitStoreType.toNumber()\n    }\n  });\n}\n\nfunction convertCompact(registry, {\n  type\n}) {\n  return registry.createType('Si1TypeDef', {\n    Compact: {\n      type: type.toNumber()\n    }\n  });\n}\n\nfunction convertComposite(registry, {\n  fields\n}) {\n  return registry.createType('Si1TypeDef', {\n    Composite: {\n      fields: convertFields(registry, fields)\n    }\n  });\n}\n\nfunction convertFields(registry, fields) {\n  return fields.map(({\n    docs,\n    name,\n    type,\n    typeName\n  }) => registry.createType('Si1Field', {\n    docs,\n    name,\n    type: type.toNumber(),\n    typeName\n  }));\n}\n\nfunction convertPhantom(registry, path) {\n  console.warn(`Converting phantom type ${path.map(p => p.toString()).join('::')} to empty tuple`);\n  return registry.createType('Si1TypeDef', {\n    Tuple: []\n  });\n}\n\nfunction convertPrimitive(registry, prim) {\n  return registry.createType('Si1TypeDef', {\n    Primitive: prim.toString()\n  });\n}\n\nfunction convertSequence(registry, {\n  type\n}) {\n  return registry.createType('Si1TypeDef', {\n    Sequence: {\n      type: type.toNumber()\n    }\n  });\n}\n\nfunction convertTuple(registry, types) {\n  return registry.createType('Si1TypeDef', {\n    Tuple: types.map(t => t.toNumber())\n  });\n}\n\nfunction convertVariant(registry, {\n  variants\n}) {\n  return registry.createType('Si1TypeDef', {\n    Variant: {\n      variants: variants.map(({\n        discriminant,\n        docs,\n        fields,\n        name\n      }, index) => registry.createType('Si1Variant', {\n        docs,\n        fields: convertFields(registry, fields),\n        index: discriminant.isSome ? discriminant.unwrap().toNumber() : index,\n        name\n      }))\n    }\n  });\n}\n\nfunction convertDef(registry, {\n  def,\n  path\n}) {\n  if (def.isArray) {\n    return convertArray(registry, def.asArray);\n  } else if (def.isBitSequence) {\n    return convertBitSequence(registry, def.asBitSequence);\n  } else if (def.isCompact) {\n    return convertCompact(registry, def.asCompact);\n  } else if (def.isComposite) {\n    return convertComposite(registry, def.asComposite);\n  } else if (def.isPhantom) {\n    return convertPhantom(registry, path);\n  } else if (def.isPrimitive) {\n    return convertPrimitive(registry, def.asPrimitive);\n  } else if (def.isSequence) {\n    return convertSequence(registry, def.asSequence);\n  } else if (def.isTuple) {\n    return convertTuple(registry, def.asTuple);\n  } else if (def.isVariant) {\n    return convertVariant(registry, def.asVariant);\n  }\n\n  throw new Error(`Cannot convert type ${def.toString()}`);\n}\n\nexport function toV1(registry, types) {\n  return types.map((t, id) => registry.createType('PortableType', {\n    id,\n    type: {\n      def: convertDef(registry, t),\n      docs: [],\n      params: t.params.map(p => p.toNumber()),\n      path: t.path.map(p => p.toString())\n    }\n  }));\n}","map":{"version":3,"sources":["/Users/mario/p/dapp-test/node_modules/@polkadot/types/generic/PortableRegistry/toV1.js"],"names":["convertArray","registry","len","type","createType","Array","toNumber","convertBitSequence","bitOrderType","bitStoreType","BitSequence","convertCompact","Compact","convertComposite","fields","Composite","convertFields","map","docs","name","typeName","convertPhantom","path","console","warn","p","toString","join","Tuple","convertPrimitive","prim","Primitive","convertSequence","Sequence","convertTuple","types","t","convertVariant","variants","Variant","discriminant","index","isSome","unwrap","convertDef","def","isArray","asArray","isBitSequence","asBitSequence","isCompact","asCompact","isComposite","asComposite","isPhantom","isPrimitive","asPrimitive","isSequence","asSequence","isTuple","asTuple","isVariant","asVariant","Error","toV1","id","params"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nfunction convertArray(registry, {\n  len,\n  type\n}) {\n  return registry.createType('Si1TypeDef', {\n    Array: {\n      len,\n      type: type.toNumber()\n    }\n  });\n}\n\nfunction convertBitSequence(registry, {\n  bitOrderType,\n  bitStoreType\n}) {\n  return registry.createType('Si1TypeDef', {\n    BitSequence: {\n      bitOrderType: bitOrderType.toNumber(),\n      bitStoreType: bitStoreType.toNumber()\n    }\n  });\n}\n\nfunction convertCompact(registry, {\n  type\n}) {\n  return registry.createType('Si1TypeDef', {\n    Compact: {\n      type: type.toNumber()\n    }\n  });\n}\n\nfunction convertComposite(registry, {\n  fields\n}) {\n  return registry.createType('Si1TypeDef', {\n    Composite: {\n      fields: convertFields(registry, fields)\n    }\n  });\n}\n\nfunction convertFields(registry, fields) {\n  return fields.map(({\n    docs,\n    name,\n    type,\n    typeName\n  }) => registry.createType('Si1Field', {\n    docs,\n    name,\n    type: type.toNumber(),\n    typeName\n  }));\n}\n\nfunction convertPhantom(registry, path) {\n  console.warn(`Converting phantom type ${path.map(p => p.toString()).join('::')} to empty tuple`);\n  return registry.createType('Si1TypeDef', {\n    Tuple: []\n  });\n}\n\nfunction convertPrimitive(registry, prim) {\n  return registry.createType('Si1TypeDef', {\n    Primitive: prim.toString()\n  });\n}\n\nfunction convertSequence(registry, {\n  type\n}) {\n  return registry.createType('Si1TypeDef', {\n    Sequence: {\n      type: type.toNumber()\n    }\n  });\n}\n\nfunction convertTuple(registry, types) {\n  return registry.createType('Si1TypeDef', {\n    Tuple: types.map(t => t.toNumber())\n  });\n}\n\nfunction convertVariant(registry, {\n  variants\n}) {\n  return registry.createType('Si1TypeDef', {\n    Variant: {\n      variants: variants.map(({\n        discriminant,\n        docs,\n        fields,\n        name\n      }, index) => registry.createType('Si1Variant', {\n        docs,\n        fields: convertFields(registry, fields),\n        index: discriminant.isSome ? discriminant.unwrap().toNumber() : index,\n        name\n      }))\n    }\n  });\n}\n\nfunction convertDef(registry, {\n  def,\n  path\n}) {\n  if (def.isArray) {\n    return convertArray(registry, def.asArray);\n  } else if (def.isBitSequence) {\n    return convertBitSequence(registry, def.asBitSequence);\n  } else if (def.isCompact) {\n    return convertCompact(registry, def.asCompact);\n  } else if (def.isComposite) {\n    return convertComposite(registry, def.asComposite);\n  } else if (def.isPhantom) {\n    return convertPhantom(registry, path);\n  } else if (def.isPrimitive) {\n    return convertPrimitive(registry, def.asPrimitive);\n  } else if (def.isSequence) {\n    return convertSequence(registry, def.asSequence);\n  } else if (def.isTuple) {\n    return convertTuple(registry, def.asTuple);\n  } else if (def.isVariant) {\n    return convertVariant(registry, def.asVariant);\n  }\n\n  throw new Error(`Cannot convert type ${def.toString()}`);\n}\n\nexport function toV1(registry, types) {\n  return types.map((t, id) => registry.createType('PortableType', {\n    id,\n    type: {\n      def: convertDef(registry, t),\n      docs: [],\n      params: t.params.map(p => p.toNumber()),\n      path: t.path.map(p => p.toString())\n    }\n  }));\n}"]},"metadata":{},"sourceType":"module"}