{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2019-2021 @polkadot/extension-dapp authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { u8aEq } from '@polkadot/util';\nimport { decodeAddress, encodeAddress } from '@polkadot/util-crypto';\nimport { documentReadyPromise } from \"./util.js\"; // expose utility functions\n\nexport { unwrapBytes, wrapBytes } from \"./wrapBytes.js\"; // just a helper (otherwise we cast all-over, so shorter and more readable)\n\nconst win = window; // don't clobber the existing object, but ensure non-undefined\n\nwin.injectedWeb3 = win.injectedWeb3 || {}; // true when anything has been injected and is available\n\nfunction web3IsInjected() {\n  return Object.keys(win.injectedWeb3).length !== 0;\n} // helper to throw a consistent error when not enabled\n\n\nfunction throwError(method) {\n  throw new Error(`${method}: web3Enable(originName) needs to be called before ${method}`);\n} // internal helper to map from Array<InjectedAccount> -> Array<InjectedAccountWithMeta>\n\n\nfunction mapAccounts(source, list, ss58Format) {\n  return list.map(({\n    address,\n    genesisHash,\n    name,\n    type\n  }) => {\n    const encodedAddress = address.length === 42 ? address : encodeAddress(decodeAddress(address), ss58Format);\n    return {\n      address: encodedAddress,\n      meta: {\n        genesisHash,\n        name,\n        source\n      },\n      type\n    };\n  });\n} // have we found a properly constructed window.injectedWeb3\n\n\nlet isWeb3Injected = web3IsInjected(); // we keep the last promise created around (for queries)\n\nlet web3EnablePromise = null;\nexport { isWeb3Injected, web3EnablePromise };\n\nfunction getWindowExtensions(originName) {\n  return Promise.all(Object.entries(win.injectedWeb3).map(([name, {\n    enable,\n    version\n  }]) => Promise.all([Promise.resolve({\n    name,\n    version\n  }), enable(originName).catch(error => {\n    console.error(`Error initializing ${name}: ${error.message}`);\n  })])));\n} // enables all the providers found on the injected window interface\n\n\nexport function web3Enable(originName, compatInits = []) {\n  if (!originName) {\n    throw new Error('You must pass a name for your app to the web3Enable function');\n  }\n\n  const initCompat = compatInits.length ? Promise.all(compatInits.map(c => c().catch(() => false))) : Promise.resolve([true]);\n  web3EnablePromise = documentReadyPromise(() => initCompat.then(() => getWindowExtensions(originName).then(values => values.filter(value => !!value[1]).map(([info, ext]) => {\n    // if we don't have an accounts subscriber, add a single-shot version\n    if (!ext.accounts.subscribe) {\n      ext.accounts.subscribe = cb => {\n        ext.accounts.get().then(cb).catch(console.error);\n        return () => {// no ubsubscribe needed, this is a single-shot\n        };\n      };\n    }\n\n    return _objectSpread(_objectSpread({}, info), ext);\n  })).catch(() => []).then(values => {\n    const names = values.map(({\n      name,\n      version\n    }) => `${name}/${version}`);\n    isWeb3Injected = web3IsInjected();\n    console.log(`web3Enable: Enabled ${values.length} extension${values.length !== 1 ? 's' : ''}: ${names.join(', ')}`);\n    return values;\n  })));\n  return web3EnablePromise;\n} // retrieve all the accounts across all providers\n\nexport async function web3Accounts({\n  accountType,\n  ss58Format\n} = {}) {\n  if (!web3EnablePromise) {\n    return throwError('web3Accounts');\n  }\n\n  const accounts = [];\n  const injected = await web3EnablePromise;\n  const retrieved = await Promise.all(injected.map(async ({\n    accounts,\n    name: source\n  }) => {\n    try {\n      const list = await accounts.get();\n      return mapAccounts(source, list.filter(({\n        type\n      }) => type && accountType ? accountType.includes(type) : true), ss58Format);\n    } catch (error) {\n      // cannot handle this one\n      return [];\n    }\n  }));\n  retrieved.forEach(result => {\n    accounts.push(...result);\n  });\n  const addresses = accounts.map(({\n    address\n  }) => address);\n  console.log(`web3Accounts: Found ${accounts.length} address${accounts.length !== 1 ? 'es' : ''}: ${addresses.join(', ')}`);\n  return accounts;\n}\nexport async function web3AccountsSubscribe(cb, {\n  ss58Format\n} = {}) {\n  if (!web3EnablePromise) {\n    return throwError('web3AccountsSubscribe');\n  }\n\n  const accounts = {};\n\n  const triggerUpdate = () => cb(Object.entries(accounts).reduce((result, [source, list]) => {\n    result.push(...mapAccounts(source, list, ss58Format));\n    return result;\n  }, []));\n\n  const unsubs = (await web3EnablePromise).map(({\n    accounts: {\n      subscribe\n    },\n    name: source\n  }) => subscribe(result => {\n    accounts[source] = result; // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n    triggerUpdate();\n  }));\n  return () => {\n    unsubs.forEach(unsub => {\n      unsub();\n    });\n  };\n} // find a specific provider based on the name\n\nexport async function web3FromSource(source) {\n  if (!web3EnablePromise) {\n    return throwError('web3FromSource');\n  }\n\n  const sources = await web3EnablePromise;\n  const found = source && sources.find(({\n    name\n  }) => name === source);\n\n  if (!found) {\n    throw new Error(`web3FromSource: Unable to find an injected ${source}`);\n  }\n\n  return found;\n} // find a specific provider based on an address\n\nexport async function web3FromAddress(address) {\n  if (!web3EnablePromise) {\n    return throwError('web3FromAddress');\n  }\n\n  const accounts = await web3Accounts();\n  let found;\n\n  if (address) {\n    const accountU8a = decodeAddress(address);\n    found = accounts.find(account => u8aEq(decodeAddress(account.address), accountU8a));\n  }\n\n  if (!found) {\n    throw new Error(`web3FromAddress: Unable to find injected ${address}`);\n  }\n\n  return web3FromSource(found.meta.source);\n} // retrieve all providers exposed by one source\n\nexport async function web3ListRpcProviders(source) {\n  const {\n    provider\n  } = await web3FromSource(source);\n\n  if (!provider) {\n    console.warn(`Extension ${source} does not expose any provider`);\n    return null;\n  }\n\n  return provider.listProviders();\n} // retrieve all providers exposed by one source\n\nexport async function web3UseRpcProvider(source, key) {\n  const {\n    provider\n  } = await web3FromSource(source);\n\n  if (!provider) {\n    throw new Error(`Extension ${source} does not expose any provider`);\n  }\n\n  const meta = await provider.startProvider(key);\n  return {\n    meta,\n    provider\n  };\n}","map":{"version":3,"sources":["/Users/mario/p/dapp-test/node_modules/@polkadot/extension-dapp/index.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","u8aEq","decodeAddress","encodeAddress","documentReadyPromise","unwrapBytes","wrapBytes","win","window","injectedWeb3","web3IsInjected","throwError","method","Error","mapAccounts","list","ss58Format","map","address","genesisHash","name","type","encodedAddress","meta","isWeb3Injected","web3EnablePromise","getWindowExtensions","originName","Promise","all","entries","enable","version","resolve","catch","error","console","message","web3Enable","compatInits","initCompat","c","then","values","value","info","ext","accounts","subscribe","cb","get","names","log","join","web3Accounts","accountType","injected","retrieved","includes","result","addresses","web3AccountsSubscribe","triggerUpdate","reduce","unsubs","unsub","web3FromSource","sources","found","find","web3FromAddress","accountU8a","account","web3ListRpcProviders","provider","warn","listProviders","web3UseRpcProvider","startProvider"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2019-2021 @polkadot/extension-dapp authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { u8aEq } from '@polkadot/util';\nimport { decodeAddress, encodeAddress } from '@polkadot/util-crypto';\nimport { documentReadyPromise } from \"./util.js\"; // expose utility functions\n\nexport { unwrapBytes, wrapBytes } from \"./wrapBytes.js\"; // just a helper (otherwise we cast all-over, so shorter and more readable)\n\nconst win = window; // don't clobber the existing object, but ensure non-undefined\n\nwin.injectedWeb3 = win.injectedWeb3 || {}; // true when anything has been injected and is available\n\nfunction web3IsInjected() {\n  return Object.keys(win.injectedWeb3).length !== 0;\n} // helper to throw a consistent error when not enabled\n\n\nfunction throwError(method) {\n  throw new Error(`${method}: web3Enable(originName) needs to be called before ${method}`);\n} // internal helper to map from Array<InjectedAccount> -> Array<InjectedAccountWithMeta>\n\n\nfunction mapAccounts(source, list, ss58Format) {\n  return list.map(({\n    address,\n    genesisHash,\n    name,\n    type\n  }) => {\n    const encodedAddress = address.length === 42 ? address : encodeAddress(decodeAddress(address), ss58Format);\n    return {\n      address: encodedAddress,\n      meta: {\n        genesisHash,\n        name,\n        source\n      },\n      type\n    };\n  });\n} // have we found a properly constructed window.injectedWeb3\n\n\nlet isWeb3Injected = web3IsInjected(); // we keep the last promise created around (for queries)\n\nlet web3EnablePromise = null;\nexport { isWeb3Injected, web3EnablePromise };\n\nfunction getWindowExtensions(originName) {\n  return Promise.all(Object.entries(win.injectedWeb3).map(([name, {\n    enable,\n    version\n  }]) => Promise.all([Promise.resolve({\n    name,\n    version\n  }), enable(originName).catch(error => {\n    console.error(`Error initializing ${name}: ${error.message}`);\n  })])));\n} // enables all the providers found on the injected window interface\n\n\nexport function web3Enable(originName, compatInits = []) {\n  if (!originName) {\n    throw new Error('You must pass a name for your app to the web3Enable function');\n  }\n\n  const initCompat = compatInits.length ? Promise.all(compatInits.map(c => c().catch(() => false))) : Promise.resolve([true]);\n  web3EnablePromise = documentReadyPromise(() => initCompat.then(() => getWindowExtensions(originName).then(values => values.filter(value => !!value[1]).map(([info, ext]) => {\n    // if we don't have an accounts subscriber, add a single-shot version\n    if (!ext.accounts.subscribe) {\n      ext.accounts.subscribe = cb => {\n        ext.accounts.get().then(cb).catch(console.error);\n        return () => {// no ubsubscribe needed, this is a single-shot\n        };\n      };\n    }\n\n    return _objectSpread(_objectSpread({}, info), ext);\n  })).catch(() => []).then(values => {\n    const names = values.map(({\n      name,\n      version\n    }) => `${name}/${version}`);\n    isWeb3Injected = web3IsInjected();\n    console.log(`web3Enable: Enabled ${values.length} extension${values.length !== 1 ? 's' : ''}: ${names.join(', ')}`);\n    return values;\n  })));\n  return web3EnablePromise;\n} // retrieve all the accounts across all providers\n\nexport async function web3Accounts({\n  accountType,\n  ss58Format\n} = {}) {\n  if (!web3EnablePromise) {\n    return throwError('web3Accounts');\n  }\n\n  const accounts = [];\n  const injected = await web3EnablePromise;\n  const retrieved = await Promise.all(injected.map(async ({\n    accounts,\n    name: source\n  }) => {\n    try {\n      const list = await accounts.get();\n      return mapAccounts(source, list.filter(({\n        type\n      }) => type && accountType ? accountType.includes(type) : true), ss58Format);\n    } catch (error) {\n      // cannot handle this one\n      return [];\n    }\n  }));\n  retrieved.forEach(result => {\n    accounts.push(...result);\n  });\n  const addresses = accounts.map(({\n    address\n  }) => address);\n  console.log(`web3Accounts: Found ${accounts.length} address${accounts.length !== 1 ? 'es' : ''}: ${addresses.join(', ')}`);\n  return accounts;\n}\nexport async function web3AccountsSubscribe(cb, {\n  ss58Format\n} = {}) {\n  if (!web3EnablePromise) {\n    return throwError('web3AccountsSubscribe');\n  }\n\n  const accounts = {};\n\n  const triggerUpdate = () => cb(Object.entries(accounts).reduce((result, [source, list]) => {\n    result.push(...mapAccounts(source, list, ss58Format));\n    return result;\n  }, []));\n\n  const unsubs = (await web3EnablePromise).map(({\n    accounts: {\n      subscribe\n    },\n    name: source\n  }) => subscribe(result => {\n    accounts[source] = result; // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n    triggerUpdate();\n  }));\n  return () => {\n    unsubs.forEach(unsub => {\n      unsub();\n    });\n  };\n} // find a specific provider based on the name\n\nexport async function web3FromSource(source) {\n  if (!web3EnablePromise) {\n    return throwError('web3FromSource');\n  }\n\n  const sources = await web3EnablePromise;\n  const found = source && sources.find(({\n    name\n  }) => name === source);\n\n  if (!found) {\n    throw new Error(`web3FromSource: Unable to find an injected ${source}`);\n  }\n\n  return found;\n} // find a specific provider based on an address\n\nexport async function web3FromAddress(address) {\n  if (!web3EnablePromise) {\n    return throwError('web3FromAddress');\n  }\n\n  const accounts = await web3Accounts();\n  let found;\n\n  if (address) {\n    const accountU8a = decodeAddress(address);\n    found = accounts.find(account => u8aEq(decodeAddress(account.address), accountU8a));\n  }\n\n  if (!found) {\n    throw new Error(`web3FromAddress: Unable to find injected ${address}`);\n  }\n\n  return web3FromSource(found.meta.source);\n} // retrieve all providers exposed by one source\n\nexport async function web3ListRpcProviders(source) {\n  const {\n    provider\n  } = await web3FromSource(source);\n\n  if (!provider) {\n    console.warn(`Extension ${source} does not expose any provider`);\n    return null;\n  }\n\n  return provider.listProviders();\n} // retrieve all providers exposed by one source\n\nexport async function web3UseRpcProvider(source, key) {\n  const {\n    provider\n  } = await web3FromSource(source);\n\n  if (!provider) {\n    throw new Error(`Extension ${source} does not expose any provider`);\n  }\n\n  const meta = await provider.startProvider(key);\n  return {\n    meta,\n    provider\n  };\n}"]},"metadata":{},"sourceType":"module"}