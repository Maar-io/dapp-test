{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, isNumber, isString, stringCamelCase, stringify, stringUpperFirst } from '@polkadot/util';\nimport { Struct } from \"../../codec/Struct.js\";\nimport { withTypeString } from \"../../create/encodeTypes.js\";\nimport { getTypeDef } from \"../../create/getTypeDef.js\";\nimport { TypeDefInfo } from \"../../types/index.js\"; // Just a placeholder for a type.unrwapOr()\n\nconst TYPE_UNWRAP = {\n  toNumber: () => -1\n}; // Alias the primitive enum with out known values\n\nconst PRIMITIVE_ALIAS = {\n  Char: 'u32',\n  // Rust char is 4-bytes\n  Str: 'Text'\n}; // These are types where we have a specific decoding/encoding override + helpers\n\nconst PRIMITIVE_PATHS = [// match {node, polkadot, ...}_runtime\n'*_runtime::Call', '*_runtime::Event', // these have a specific encoding or logic (for pallets)\n'pallet_democracy::vote::Vote', 'pallet_identity::types::Data', // these are well-known types with additional encoding\n'sp_core::crypto::AccountId32', 'sp_runtime::generic::era::Era', 'sp_runtime::multiaddress::MultiAddress', // shorten some well-known types\n'primitive_types::*', 'sp_arithmetic::per_things::*', // ink!\n'ink_env::types::*'].map(p => p.split('::')); // Mappings for types that should be converted to set via BitVec\n\nconst SETS = ['pallet_identity::types::BitFlags'].map(p => p.split('::')); // These we never use these as top-level names, they are wrappers\n\nconst WRAPPERS = ['BoundedBTreeMap', 'BoundedVec', 'Box', 'BTreeMap', 'Cow', 'Result', 'Option', 'WeakBoundedVec', 'WrapperOpaque']; // These are reserved and/or conflicts with built-in Codec or JS definitions\n\nconst RESERVED = ['entries', 'hash', 'keys', 'new', 'size'];\n\nfunction matchParts(first, second) {\n  return first.length === second.length && first.every((a, index) => {\n    const b = second[index].toString();\n\n    if (a === '*' || a === b) {\n      return true;\n    }\n\n    if (a.includes('*') && a.includes('_') && b.includes('_')) {\n      const suba = a.split('_');\n      const subb = b.split('_');\n\n      if (suba[0] === '*') {\n        // the first parts where the length is greater is always a match\n        while (suba.length < subb.length) {\n          subb.shift();\n        }\n      }\n\n      return matchParts(suba, subb);\n    }\n\n    return false;\n  });\n} // check if the path matches the PRIMITIVE_SP (with wildcards)\n\n\nfunction getPrimitivePath(path) {\n  // TODO We need to handle ink! Balance in some way\n  return path.length && PRIMITIVE_PATHS.some(p => matchParts(p, path)) ? path[path.length - 1].toString() : null;\n}\n\nfunction removeDuplicateNames(lookup, names) {\n  const rewrite = {};\n  return names.map(([lookupIndex, name, params]) => {\n    if (!name) {\n      return [lookupIndex, null];\n    } // those where the name is matching\n\n\n    const allSame = names.filter(([, oName]) => name === oName); // are there among matching names\n\n    const anyDiff = allSame.some(([oIndex,, oParams]) => lookupIndex !== oIndex && (params.length !== oParams.length || params.some((p, index) => !p.name.eq(oParams[index].name) || p.type.unwrapOr(TYPE_UNWRAP).toNumber() !== oParams[index].type.unwrapOr(TYPE_UNWRAP).toNumber()))); // everything matches, we can combine these\n\n    if (!anyDiff || !allSame[0][2].length) {\n      return [lookupIndex, name];\n    } // find the first parameter that yields differences\n\n\n    const paramIdx = allSame[0][2].findIndex(({\n      type\n    }, index) => allSame.every(([,, params]) => params[index].type.isSome) && allSame.every(([,, params], aIndex) => aIndex === 0 || !params[index].type.eq(type))); // No param found that is different\n\n    if (paramIdx === -1) {\n      return [lookupIndex, name];\n    } // see if using the param type helps\n\n\n    const adjusted = allSame.map(([oIndex, oName, oParams]) => {\n      const {\n        def,\n        path\n      } = lookup.getSiType(oParams[paramIdx].type.unwrap());\n\n      if (!def.isPrimitive && !path.length) {\n        return [oIndex, null];\n      }\n\n      return [oIndex, def.isPrimitive ? `${oName}${def.asPrimitive.toString()}` : `${oName}${path[path.length - 1].toString()}`];\n    }); // any dupes remaining?\n\n    const noDupes = adjusted.every(([i, n]) => !!n && !adjusted.some(([ai, an]) => i !== ai && n === an));\n\n    if (noDupes) {\n      // we filtered above for null names\n      adjusted.forEach(([index, name]) => {\n        rewrite[index] = name;\n      });\n    }\n\n    return noDupes ? [lookupIndex, name] : [lookupIndex, null];\n  }).filter(n => !!n[1]).map(([lookupIndex, name]) => [lookupIndex, rewrite[lookupIndex] || name]);\n}\n\nfunction extractName(types, {\n  id,\n  type: {\n    params,\n    path\n  }\n}) {\n  const lookupIndex = id.toNumber();\n\n  if (!path.length || WRAPPERS.includes(path[path.length - 1].toString())) {\n    return [lookupIndex, null, []];\n  }\n\n  const parts = path.map(p => stringUpperFirst(stringCamelCase(p))).filter((p, index) => ( // Remove ::{pallet, traits, types}::\n  index !== 1 || !['Pallet', 'Traits', 'Types'].includes(p.toString())) && ( // sp_runtime::generic::digest::Digest -> sp_runtime::generic::Digest\n  // sp_runtime::multiaddress::MultiAddress -> sp_runtime::MultiAddress\n  index === path.length - 1 || p.toLowerCase() !== path[index + 1].toLowerCase()));\n  let typeName = parts.join('');\n\n  if (parts.length === 2 && parts[parts.length - 1] === 'RawOrigin' && params.length === 2 && params[1].type.isSome) {\n    // Do magic for RawOrigin lookup\n    const instanceType = types[params[1].type.unwrap().toNumber()];\n\n    if (instanceType.type.path.length === 2) {\n      typeName = `${typeName}${instanceType.type.path[1].toString()}`;\n    }\n  }\n\n  return [lookupIndex, typeName, params];\n}\n\nfunction extractNames(lookup, types) {\n  const dedup = removeDuplicateNames(lookup, types.map(t => extractName(types, t)));\n  const [names, typesNew] = dedup.reduce(([names, types], [lookupIndex, name]) => {\n    // We set the name for this specific type\n    names[lookupIndex] = name; // we map to the actual lookupIndex\n\n    types[name] = lookup.registry.createLookupType(lookupIndex);\n    return [names, types];\n  }, [{}, {}]);\n  lookup.registry.register(typesNew);\n  return names;\n}\n\nvar _names = /*#__PURE__*/_classPrivateFieldLooseKey(\"names\");\n\nvar _typeDefs = /*#__PURE__*/_classPrivateFieldLooseKey(\"typeDefs\");\n\nvar _createSiDef = /*#__PURE__*/_classPrivateFieldLooseKey(\"createSiDef\");\n\nvar _getLookupId = /*#__PURE__*/_classPrivateFieldLooseKey(\"getLookupId\");\n\nvar _extract = /*#__PURE__*/_classPrivateFieldLooseKey(\"extract\");\n\nvar _extractArray = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractArray\");\n\nvar _extractBitSequence = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractBitSequence\");\n\nvar _extractCompact = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractCompact\");\n\nvar _extractComposite = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractComposite\");\n\nvar _extractCompositeSet = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractCompositeSet\");\n\nvar _extractFields = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractFields\");\n\nvar _extractFieldsAlias = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractFieldsAlias\");\n\nvar _extractHistoric = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractHistoric\");\n\nvar _extractPrimitive = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractPrimitive\");\n\nvar _extractPrimitivePath = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractPrimitivePath\");\n\nvar _extractSequence = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractSequence\");\n\nvar _extractTuple = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractTuple\");\n\nvar _extractVariant = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractVariant\");\n\nvar _extractVariantEnum = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractVariantEnum\");\n\nexport class GenericPortableRegistry extends Struct {\n  constructor(registry, value) {\n    super(registry, {\n      types: 'Vec<PortableType>'\n    }, value);\n    Object.defineProperty(this, _extractVariantEnum, {\n      value: _extractVariantEnum2\n    });\n    Object.defineProperty(this, _extractVariant, {\n      value: _extractVariant2\n    });\n    Object.defineProperty(this, _extractTuple, {\n      value: _extractTuple2\n    });\n    Object.defineProperty(this, _extractSequence, {\n      value: _extractSequence2\n    });\n    Object.defineProperty(this, _extractPrimitivePath, {\n      value: _extractPrimitivePath2\n    });\n    Object.defineProperty(this, _extractPrimitive, {\n      value: _extractPrimitive2\n    });\n    Object.defineProperty(this, _extractHistoric, {\n      value: _extractHistoric2\n    });\n    Object.defineProperty(this, _extractFieldsAlias, {\n      value: _extractFieldsAlias2\n    });\n    Object.defineProperty(this, _extractFields, {\n      value: _extractFields2\n    });\n    Object.defineProperty(this, _extractCompositeSet, {\n      value: _extractCompositeSet2\n    });\n    Object.defineProperty(this, _extractComposite, {\n      value: _extractComposite2\n    });\n    Object.defineProperty(this, _extractCompact, {\n      value: _extractCompact2\n    });\n    Object.defineProperty(this, _extractBitSequence, {\n      value: _extractBitSequence2\n    });\n    Object.defineProperty(this, _extractArray, {\n      value: _extractArray2\n    });\n    Object.defineProperty(this, _extract, {\n      value: _extract2\n    });\n    Object.defineProperty(this, _getLookupId, {\n      value: _getLookupId2\n    });\n    Object.defineProperty(this, _createSiDef, {\n      value: _createSiDef2\n    });\n    Object.defineProperty(this, _names, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _typeDefs, {\n      writable: true,\n      value: {}\n    });\n    _classPrivateFieldLooseBase(this, _names)[_names] = extractNames(this, this.types);\n  }\n  /**\n   * @description The types of the registry\n   */\n\n\n  get types() {\n    return this.get('types');\n  }\n  /**\n   * @description Returns the name for a specific lookup\n   */\n\n\n  getName(lookupId) {\n    return _classPrivateFieldLooseBase(this, _names)[_names][_classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId)];\n  }\n  /**\n   * @description Finds a specific type in the registry\n   */\n\n\n  getSiType(lookupId) {\n    const found = this.types[_classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId)];\n\n    assert(found, () => `PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);\n    return found.type;\n  }\n  /**\n   * @description Lookup the type definition for the index\n   */\n\n\n  getTypeDef(lookupId) {\n    const lookupIndex = _classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId);\n\n    if (!_classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex]) {\n      const lookupName = _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex];\n\n      const empty = {\n        info: TypeDefInfo.DoNotConstruct,\n        lookupIndex,\n        lookupName,\n        type: this.registry.createLookupType(lookupIndex)\n      }; // Set named items since we will get into circular lookups along the way\n\n      if (lookupName) {\n        _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex] = empty;\n      }\n\n      const extracted = _classPrivateFieldLooseBase(this, _extract)[_extract](this.getSiType(lookupId), lookupIndex); // For non-named items, we only set this right at the end\n\n\n      if (!lookupName) {\n        _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex] = empty;\n      }\n\n      Object.keys(extracted).forEach(k => {\n        if (k !== 'lookupName' || extracted[k]) {\n          // these are safe since we are looking through the keys as set\n          _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex][k] = extracted[k];\n        }\n      }); // don't set lookupName on lower-level, we want to always direct to the type\n\n      if (extracted.info === TypeDefInfo.Plain) {\n        _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupNameRoot = _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;\n        delete _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;\n      }\n    }\n\n    return _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex];\n  }\n\n}\n\nfunction _createSiDef2(lookupId) {\n  const typeDef = this.getTypeDef(lookupId);\n  const lookupIndex = lookupId.toNumber(); // Setup for a lookup on complex types\n\n  return [TypeDefInfo.Enum, TypeDefInfo.Struct].includes(typeDef.info) && typeDef.lookupName ? {\n    docs: typeDef.docs,\n    info: TypeDefInfo.Si,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    type: this.registry.createLookupType(lookupId)\n  } : typeDef;\n}\n\nfunction _getLookupId2(lookupId) {\n  if (isString(lookupId)) {\n    assert(this.registry.isLookupType(lookupId), () => `PortableRegistry: Expected a lookup string type, found ${lookupId}`);\n    return parseInt(lookupId.replace('Lookup', ''), 10);\n  } else if (isNumber(lookupId)) {\n    return lookupId;\n  }\n\n  return lookupId.toNumber();\n}\n\nfunction _extract2(type, lookupIndex) {\n  const namespace = [...type.path].join('::');\n  let typeDef;\n  const primType = getPrimitivePath(type.path);\n\n  try {\n    if (primType) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractPrimitivePath)[_extractPrimitivePath](lookupIndex, primType);\n    } else if (type.def.isArray) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractArray)[_extractArray](lookupIndex, type.def.asArray);\n    } else if (type.def.isBitSequence) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractBitSequence)[_extractBitSequence](lookupIndex, type.def.asBitSequence);\n    } else if (type.def.isCompact) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractCompact)[_extractCompact](lookupIndex, type.def.asCompact);\n    } else if (type.def.isComposite) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractComposite)[_extractComposite](lookupIndex, type, type.def.asComposite);\n    } else if (type.def.isHistoricMetaCompat) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractHistoric)[_extractHistoric](lookupIndex, type.def.asHistoricMetaCompat);\n    } else if (type.def.isPrimitive) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractPrimitive)[_extractPrimitive](lookupIndex, type);\n    } else if (type.def.isSequence) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractSequence)[_extractSequence](lookupIndex, type.def.asSequence);\n    } else if (type.def.isTuple) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractTuple)[_extractTuple](lookupIndex, type.def.asTuple);\n    } else if (type.def.isVariant) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractVariant)[_extractVariant](lookupIndex, type, type.def.asVariant);\n    } else {\n      throw new Error(`No SiTypeDef handler for ${type.def.toString()}`);\n    }\n  } catch (error) {\n    throw new Error(`PortableRegistry: ${lookupIndex}${namespace ? ` (${namespace})` : ''}: Error extracting ${stringify(type)}: ${error.message}`);\n  }\n\n  return _objectSpread({\n    docs: type.docs.map(d => d.toString()),\n    namespace\n  }, typeDef);\n}\n\nfunction _extractArray2(_, {\n  len: length,\n  type\n}) {\n  assert(!length || length.toNumber() <= 256, 'Only support for [Type; <length>], where length <= 256');\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.VecFixed,\n    length: length.toNumber(),\n    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)\n  });\n}\n\nfunction _extractBitSequence2(_, {\n  bitOrderType,\n  bitStoreType\n}) {\n  const bitOrder = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](bitOrderType);\n\n  const bitStore = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](bitStoreType); // NOTE: Currently the BitVec type is one-way only, i.e. we only use it to decode, not\n  // re-encode stuff. As such we ignore the msb/lsb identifier given by bitOrderType, or rather\n  // we don't pass it though at all\n\n\n  assert(['bitvec::order::Lsb0', 'bitvec::order::Msb0'].includes(bitOrder.namespace || ''), () => `Unexpected bitOrder found as ${bitOrder.namespace || '<unknown>'}`);\n  assert(bitStore.info === TypeDefInfo.Plain && bitStore.type === 'u8', () => `Only u8 bitStore is currently supported, found ${bitStore.type}`);\n  return {\n    info: TypeDefInfo.Plain,\n    type: 'BitVec'\n  };\n}\n\nfunction _extractCompact2(_, {\n  type\n}) {\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Compact,\n    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)\n  });\n}\n\nfunction _extractComposite2(lookupIndex, {\n  params,\n  path\n}, {\n  fields\n}) {\n  const specialVariant = path[0].toString();\n\n  if (path.length === 1 && specialVariant === 'BTreeMap') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.BTreeMap,\n      sub: params.map(({\n        type\n      }) => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type.unwrap()))\n    });\n  } else if (['Range', 'RangeInclusive'].includes(specialVariant)) {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Range,\n      sub: fields.map(({\n        name,\n        type\n      }, index) => _objectSpread({\n        name: name.isSome ? name.unwrap().toString() : ['start', 'end'][index]\n      }, _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)))\n    });\n  } else if (path.length && path[path.length - 1].toString() === 'WrapperOpaque') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.WrapperOpaque,\n      sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap())\n    });\n  }\n\n  return SETS.some(p => matchParts(p, path)) ? _classPrivateFieldLooseBase(this, _extractCompositeSet)[_extractCompositeSet](lookupIndex, params, fields) : _classPrivateFieldLooseBase(this, _extractFields)[_extractFields](lookupIndex, fields);\n}\n\nfunction _extractCompositeSet2(_, params, fields) {\n  assert(params.length === 1 && fields.length === 1, 'Set handling expects param/field as single entries');\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Set,\n    length: this.registry.createType(this.registry.createLookupType(fields[0].type)).bitLength(),\n    sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(({\n      index,\n      name\n    }) => ({\n      // This will be an issue > 2^53 - 1 ... don't have those (yet)\n      index: index.toNumber(),\n      info: TypeDefInfo.Plain,\n      name: name.toString(),\n      type: 'Null'\n    }))\n  });\n}\n\nfunction _extractFields2(lookupIndex, fields) {\n  const [isStruct, isTuple] = fields.reduce(([isAllNamed, isAllUnnamed], {\n    name\n  }) => [isAllNamed && name.isSome, isAllUnnamed && name.isNone], [true, true]);\n  assert(isTuple || isStruct, 'Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)');\n\n  if (fields.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  } else if (isTuple && fields.length === 1) {\n    const typeDef = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](fields[0].type);\n\n    return _objectSpread(_objectSpread({}, typeDef), lookupIndex === -1 ? {} : {\n      lookupIndex,\n      lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n      lookupNameRoot: typeDef.lookupName\n    });\n  }\n\n  const [sub, alias] = _classPrivateFieldLooseBase(this, _extractFieldsAlias)[_extractFieldsAlias](fields);\n\n  return withTypeString(this.registry, _objectSpread(_objectSpread(_objectSpread({\n    info: isTuple // Tuple check first\n    ? TypeDefInfo.Tuple : TypeDefInfo.Struct\n  }, alias.size ? {\n    alias\n  } : {}), lookupIndex === -1 ? {} : {\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex]\n  }), {}, {\n    sub\n  }));\n}\n\nfunction _extractFieldsAlias2(fields) {\n  const alias = new Map();\n  const sub = fields.map(({\n    docs,\n    name,\n    type\n  }) => {\n    const typeDef = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type);\n\n    if (name.isNone) {\n      return typeDef;\n    }\n\n    let nameField = stringCamelCase(name.unwrap());\n    let nameOrig = null;\n\n    if (nameField.includes('#')) {\n      nameOrig = nameField;\n      nameField = nameOrig.replace(/#/g, '_');\n    } else if (RESERVED.includes(nameField)) {\n      nameOrig = nameField;\n      nameField = `${nameField}_`;\n    }\n\n    if (nameOrig) {\n      alias.set(nameField, nameOrig);\n    }\n\n    return _objectSpread(_objectSpread({}, typeDef), {}, {\n      docs: docs.map(d => d.toString()),\n      name: nameField\n    });\n  });\n  return [sub, alias];\n}\n\nfunction _extractHistoric2(_, type) {\n  return _objectSpread(_objectSpread({}, getTypeDef(type)), {}, {\n    displayName: type.toString(),\n    isFromSi: true\n  });\n}\n\nfunction _extractPrimitive2(_, type) {\n  const typeStr = type.def.asPrimitive.type.toString();\n  return {\n    info: TypeDefInfo.Plain,\n    type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()\n  };\n}\n\nfunction _extractPrimitivePath2(_, type) {\n  return {\n    info: TypeDefInfo.Plain,\n    type\n  };\n}\n\nfunction _extractSequence2(lookupIndex, {\n  type\n}) {\n  const sub = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type);\n\n  if (sub.type === 'u8') {\n    return {\n      info: TypeDefInfo.Plain,\n      type: 'Bytes'\n    };\n  }\n\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Vec,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}\n\nfunction _extractTuple2(lookupIndex, ids) {\n  if (ids.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  } else if (ids.length === 1) {\n    return this.getTypeDef(ids[0]);\n  }\n\n  const sub = ids.map(type => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type));\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Tuple,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}\n\nfunction _extractVariant2(lookupIndex, {\n  params,\n  path\n}, {\n  variants\n}) {\n  const specialVariant = path[0].toString();\n\n  if (specialVariant === 'Option') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Option,\n      sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap())\n    });\n  } else if (specialVariant === 'Result') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Result,\n      sub: params.map(({\n        type\n      }, index) => _objectSpread({\n        name: ['Ok', 'Error'][index]\n      }, _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type.unwrap())))\n    });\n  } else if (variants.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  }\n\n  return _classPrivateFieldLooseBase(this, _extractVariantEnum)[_extractVariantEnum](lookupIndex, variants);\n}\n\nfunction _extractVariantEnum2(lookupIndex, variants) {\n  const sub = []; // we may get entries out of order, arrange them first before creating with gaps filled\n  // NOTE: Since we mutate, use a copy of the array as an input\n\n  [...variants].sort((a, b) => a.index.cmp(b.index)).forEach(({\n    fields,\n    index,\n    name\n  }) => {\n    const desired = index.toNumber();\n\n    while (sub.length !== desired) {\n      sub.push({\n        index: sub.length,\n        info: TypeDefInfo.Null,\n        name: `Unused${sub.length}`,\n        type: 'Null'\n      });\n    }\n\n    sub.push(_objectSpread(_objectSpread({}, _classPrivateFieldLooseBase(this, _extractFields)[_extractFields](-1, fields)), {}, {\n      index: index.toNumber(),\n      name: name.toString()\n    }));\n  });\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Enum,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}","map":{"version":3,"sources":["/Users/mario/p/dapp-test/node_modules/@polkadot/types/generic/PortableRegistry/PortableRegistry.js"],"names":["_defineProperty","_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","assert","isNumber","isString","stringCamelCase","stringify","stringUpperFirst","Struct","withTypeString","getTypeDef","TypeDefInfo","TYPE_UNWRAP","toNumber","PRIMITIVE_ALIAS","Char","Str","PRIMITIVE_PATHS","map","p","split","SETS","WRAPPERS","RESERVED","matchParts","first","second","every","a","index","b","toString","includes","suba","subb","shift","getPrimitivePath","path","some","removeDuplicateNames","lookup","names","rewrite","lookupIndex","name","params","allSame","oName","anyDiff","oIndex","oParams","eq","type","unwrapOr","paramIdx","findIndex","isSome","aIndex","adjusted","def","getSiType","unwrap","isPrimitive","asPrimitive","noDupes","n","ai","an","extractName","types","id","parts","toLowerCase","typeName","join","instanceType","extractNames","dedup","t","typesNew","reduce","registry","createLookupType","register","_names","_typeDefs","_createSiDef","_getLookupId","_extract","_extractArray","_extractBitSequence","_extractCompact","_extractComposite","_extractCompositeSet","_extractFields","_extractFieldsAlias","_extractHistoric","_extractPrimitive","_extractPrimitivePath","_extractSequence","_extractTuple","_extractVariant","_extractVariantEnum","GenericPortableRegistry","constructor","value","_extractVariantEnum2","_extractVariant2","_extractTuple2","_extractSequence2","_extractPrimitivePath2","_extractPrimitive2","_extractHistoric2","_extractFieldsAlias2","_extractFields2","_extractCompositeSet2","_extractComposite2","_extractCompact2","_extractBitSequence2","_extractArray2","_extract2","_getLookupId2","_createSiDef2","writable","get","getName","lookupId","found","lookupName","empty","info","DoNotConstruct","extracted","k","Plain","lookupNameRoot","typeDef","Enum","docs","Si","isLookupType","parseInt","replace","namespace","primType","isArray","asArray","isBitSequence","asBitSequence","isCompact","asCompact","isComposite","asComposite","isHistoricMetaCompat","asHistoricMetaCompat","isSequence","asSequence","isTuple","asTuple","isVariant","asVariant","Error","error","message","d","_","len","VecFixed","sub","bitOrderType","bitStoreType","bitOrder","bitStore","Compact","fields","specialVariant","BTreeMap","Range","WrapperOpaque","Set","createType","bitLength","variants","isStruct","isAllNamed","isAllUnnamed","isNone","Null","alias","Tuple","size","Map","nameField","nameOrig","set","displayName","isFromSi","typeStr","Vec","ids","Option","Result","sort","cmp","desired"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isNumber, isString, stringCamelCase, stringify, stringUpperFirst } from '@polkadot/util';\nimport { Struct } from \"../../codec/Struct.js\";\nimport { withTypeString } from \"../../create/encodeTypes.js\";\nimport { getTypeDef } from \"../../create/getTypeDef.js\";\nimport { TypeDefInfo } from \"../../types/index.js\"; // Just a placeholder for a type.unrwapOr()\n\nconst TYPE_UNWRAP = {\n  toNumber: () => -1\n}; // Alias the primitive enum with out known values\n\nconst PRIMITIVE_ALIAS = {\n  Char: 'u32',\n  // Rust char is 4-bytes\n  Str: 'Text'\n}; // These are types where we have a specific decoding/encoding override + helpers\n\nconst PRIMITIVE_PATHS = [// match {node, polkadot, ...}_runtime\n'*_runtime::Call', '*_runtime::Event', // these have a specific encoding or logic (for pallets)\n'pallet_democracy::vote::Vote', 'pallet_identity::types::Data', // these are well-known types with additional encoding\n'sp_core::crypto::AccountId32', 'sp_runtime::generic::era::Era', 'sp_runtime::multiaddress::MultiAddress', // shorten some well-known types\n'primitive_types::*', 'sp_arithmetic::per_things::*', // ink!\n'ink_env::types::*'].map(p => p.split('::')); // Mappings for types that should be converted to set via BitVec\n\nconst SETS = ['pallet_identity::types::BitFlags'].map(p => p.split('::')); // These we never use these as top-level names, they are wrappers\n\nconst WRAPPERS = ['BoundedBTreeMap', 'BoundedVec', 'Box', 'BTreeMap', 'Cow', 'Result', 'Option', 'WeakBoundedVec', 'WrapperOpaque']; // These are reserved and/or conflicts with built-in Codec or JS definitions\n\nconst RESERVED = ['entries', 'hash', 'keys', 'new', 'size'];\n\nfunction matchParts(first, second) {\n  return first.length === second.length && first.every((a, index) => {\n    const b = second[index].toString();\n\n    if (a === '*' || a === b) {\n      return true;\n    }\n\n    if (a.includes('*') && a.includes('_') && b.includes('_')) {\n      const suba = a.split('_');\n      const subb = b.split('_');\n\n      if (suba[0] === '*') {\n        // the first parts where the length is greater is always a match\n        while (suba.length < subb.length) {\n          subb.shift();\n        }\n      }\n\n      return matchParts(suba, subb);\n    }\n\n    return false;\n  });\n} // check if the path matches the PRIMITIVE_SP (with wildcards)\n\n\nfunction getPrimitivePath(path) {\n  // TODO We need to handle ink! Balance in some way\n  return path.length && PRIMITIVE_PATHS.some(p => matchParts(p, path)) ? path[path.length - 1].toString() : null;\n}\n\nfunction removeDuplicateNames(lookup, names) {\n  const rewrite = {};\n  return names.map(([lookupIndex, name, params]) => {\n    if (!name) {\n      return [lookupIndex, null];\n    } // those where the name is matching\n\n\n    const allSame = names.filter(([, oName]) => name === oName); // are there among matching names\n\n    const anyDiff = allSame.some(([oIndex,, oParams]) => lookupIndex !== oIndex && (params.length !== oParams.length || params.some((p, index) => !p.name.eq(oParams[index].name) || p.type.unwrapOr(TYPE_UNWRAP).toNumber() !== oParams[index].type.unwrapOr(TYPE_UNWRAP).toNumber()))); // everything matches, we can combine these\n\n    if (!anyDiff || !allSame[0][2].length) {\n      return [lookupIndex, name];\n    } // find the first parameter that yields differences\n\n\n    const paramIdx = allSame[0][2].findIndex(({\n      type\n    }, index) => allSame.every(([,, params]) => params[index].type.isSome) && allSame.every(([,, params], aIndex) => aIndex === 0 || !params[index].type.eq(type))); // No param found that is different\n\n    if (paramIdx === -1) {\n      return [lookupIndex, name];\n    } // see if using the param type helps\n\n\n    const adjusted = allSame.map(([oIndex, oName, oParams]) => {\n      const {\n        def,\n        path\n      } = lookup.getSiType(oParams[paramIdx].type.unwrap());\n\n      if (!def.isPrimitive && !path.length) {\n        return [oIndex, null];\n      }\n\n      return [oIndex, def.isPrimitive ? `${oName}${def.asPrimitive.toString()}` : `${oName}${path[path.length - 1].toString()}`];\n    }); // any dupes remaining?\n\n    const noDupes = adjusted.every(([i, n]) => !!n && !adjusted.some(([ai, an]) => i !== ai && n === an));\n\n    if (noDupes) {\n      // we filtered above for null names\n      adjusted.forEach(([index, name]) => {\n        rewrite[index] = name;\n      });\n    }\n\n    return noDupes ? [lookupIndex, name] : [lookupIndex, null];\n  }).filter(n => !!n[1]).map(([lookupIndex, name]) => [lookupIndex, rewrite[lookupIndex] || name]);\n}\n\nfunction extractName(types, {\n  id,\n  type: {\n    params,\n    path\n  }\n}) {\n  const lookupIndex = id.toNumber();\n\n  if (!path.length || WRAPPERS.includes(path[path.length - 1].toString())) {\n    return [lookupIndex, null, []];\n  }\n\n  const parts = path.map(p => stringUpperFirst(stringCamelCase(p))).filter((p, index) => ( // Remove ::{pallet, traits, types}::\n  index !== 1 || !['Pallet', 'Traits', 'Types'].includes(p.toString())) && ( // sp_runtime::generic::digest::Digest -> sp_runtime::generic::Digest\n  // sp_runtime::multiaddress::MultiAddress -> sp_runtime::MultiAddress\n  index === path.length - 1 || p.toLowerCase() !== path[index + 1].toLowerCase()));\n  let typeName = parts.join('');\n\n  if (parts.length === 2 && parts[parts.length - 1] === 'RawOrigin' && params.length === 2 && params[1].type.isSome) {\n    // Do magic for RawOrigin lookup\n    const instanceType = types[params[1].type.unwrap().toNumber()];\n\n    if (instanceType.type.path.length === 2) {\n      typeName = `${typeName}${instanceType.type.path[1].toString()}`;\n    }\n  }\n\n  return [lookupIndex, typeName, params];\n}\n\nfunction extractNames(lookup, types) {\n  const dedup = removeDuplicateNames(lookup, types.map(t => extractName(types, t)));\n  const [names, typesNew] = dedup.reduce(([names, types], [lookupIndex, name]) => {\n    // We set the name for this specific type\n    names[lookupIndex] = name; // we map to the actual lookupIndex\n\n    types[name] = lookup.registry.createLookupType(lookupIndex);\n    return [names, types];\n  }, [{}, {}]);\n  lookup.registry.register(typesNew);\n  return names;\n}\n\nvar _names = /*#__PURE__*/_classPrivateFieldLooseKey(\"names\");\n\nvar _typeDefs = /*#__PURE__*/_classPrivateFieldLooseKey(\"typeDefs\");\n\nvar _createSiDef = /*#__PURE__*/_classPrivateFieldLooseKey(\"createSiDef\");\n\nvar _getLookupId = /*#__PURE__*/_classPrivateFieldLooseKey(\"getLookupId\");\n\nvar _extract = /*#__PURE__*/_classPrivateFieldLooseKey(\"extract\");\n\nvar _extractArray = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractArray\");\n\nvar _extractBitSequence = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractBitSequence\");\n\nvar _extractCompact = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractCompact\");\n\nvar _extractComposite = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractComposite\");\n\nvar _extractCompositeSet = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractCompositeSet\");\n\nvar _extractFields = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractFields\");\n\nvar _extractFieldsAlias = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractFieldsAlias\");\n\nvar _extractHistoric = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractHistoric\");\n\nvar _extractPrimitive = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractPrimitive\");\n\nvar _extractPrimitivePath = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractPrimitivePath\");\n\nvar _extractSequence = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractSequence\");\n\nvar _extractTuple = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractTuple\");\n\nvar _extractVariant = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractVariant\");\n\nvar _extractVariantEnum = /*#__PURE__*/_classPrivateFieldLooseKey(\"extractVariantEnum\");\n\nexport class GenericPortableRegistry extends Struct {\n  constructor(registry, value) {\n    super(registry, {\n      types: 'Vec<PortableType>'\n    }, value);\n    Object.defineProperty(this, _extractVariantEnum, {\n      value: _extractVariantEnum2\n    });\n    Object.defineProperty(this, _extractVariant, {\n      value: _extractVariant2\n    });\n    Object.defineProperty(this, _extractTuple, {\n      value: _extractTuple2\n    });\n    Object.defineProperty(this, _extractSequence, {\n      value: _extractSequence2\n    });\n    Object.defineProperty(this, _extractPrimitivePath, {\n      value: _extractPrimitivePath2\n    });\n    Object.defineProperty(this, _extractPrimitive, {\n      value: _extractPrimitive2\n    });\n    Object.defineProperty(this, _extractHistoric, {\n      value: _extractHistoric2\n    });\n    Object.defineProperty(this, _extractFieldsAlias, {\n      value: _extractFieldsAlias2\n    });\n    Object.defineProperty(this, _extractFields, {\n      value: _extractFields2\n    });\n    Object.defineProperty(this, _extractCompositeSet, {\n      value: _extractCompositeSet2\n    });\n    Object.defineProperty(this, _extractComposite, {\n      value: _extractComposite2\n    });\n    Object.defineProperty(this, _extractCompact, {\n      value: _extractCompact2\n    });\n    Object.defineProperty(this, _extractBitSequence, {\n      value: _extractBitSequence2\n    });\n    Object.defineProperty(this, _extractArray, {\n      value: _extractArray2\n    });\n    Object.defineProperty(this, _extract, {\n      value: _extract2\n    });\n    Object.defineProperty(this, _getLookupId, {\n      value: _getLookupId2\n    });\n    Object.defineProperty(this, _createSiDef, {\n      value: _createSiDef2\n    });\n    Object.defineProperty(this, _names, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _typeDefs, {\n      writable: true,\n      value: {}\n    });\n    _classPrivateFieldLooseBase(this, _names)[_names] = extractNames(this, this.types);\n  }\n  /**\n   * @description The types of the registry\n   */\n\n\n  get types() {\n    return this.get('types');\n  }\n  /**\n   * @description Returns the name for a specific lookup\n   */\n\n\n  getName(lookupId) {\n    return _classPrivateFieldLooseBase(this, _names)[_names][_classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId)];\n  }\n  /**\n   * @description Finds a specific type in the registry\n   */\n\n\n  getSiType(lookupId) {\n    const found = this.types[_classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId)];\n\n    assert(found, () => `PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);\n    return found.type;\n  }\n  /**\n   * @description Lookup the type definition for the index\n   */\n\n\n  getTypeDef(lookupId) {\n    const lookupIndex = _classPrivateFieldLooseBase(this, _getLookupId)[_getLookupId](lookupId);\n\n    if (!_classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex]) {\n      const lookupName = _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex];\n\n      const empty = {\n        info: TypeDefInfo.DoNotConstruct,\n        lookupIndex,\n        lookupName,\n        type: this.registry.createLookupType(lookupIndex)\n      }; // Set named items since we will get into circular lookups along the way\n\n      if (lookupName) {\n        _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex] = empty;\n      }\n\n      const extracted = _classPrivateFieldLooseBase(this, _extract)[_extract](this.getSiType(lookupId), lookupIndex); // For non-named items, we only set this right at the end\n\n\n      if (!lookupName) {\n        _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex] = empty;\n      }\n\n      Object.keys(extracted).forEach(k => {\n        if (k !== 'lookupName' || extracted[k]) {\n          // these are safe since we are looking through the keys as set\n          _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex][k] = extracted[k];\n        }\n      }); // don't set lookupName on lower-level, we want to always direct to the type\n\n      if (extracted.info === TypeDefInfo.Plain) {\n        _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupNameRoot = _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;\n        delete _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;\n      }\n    }\n\n    return _classPrivateFieldLooseBase(this, _typeDefs)[_typeDefs][lookupIndex];\n  }\n\n}\n\nfunction _createSiDef2(lookupId) {\n  const typeDef = this.getTypeDef(lookupId);\n  const lookupIndex = lookupId.toNumber(); // Setup for a lookup on complex types\n\n  return [TypeDefInfo.Enum, TypeDefInfo.Struct].includes(typeDef.info) && typeDef.lookupName ? {\n    docs: typeDef.docs,\n    info: TypeDefInfo.Si,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    type: this.registry.createLookupType(lookupId)\n  } : typeDef;\n}\n\nfunction _getLookupId2(lookupId) {\n  if (isString(lookupId)) {\n    assert(this.registry.isLookupType(lookupId), () => `PortableRegistry: Expected a lookup string type, found ${lookupId}`);\n    return parseInt(lookupId.replace('Lookup', ''), 10);\n  } else if (isNumber(lookupId)) {\n    return lookupId;\n  }\n\n  return lookupId.toNumber();\n}\n\nfunction _extract2(type, lookupIndex) {\n  const namespace = [...type.path].join('::');\n  let typeDef;\n  const primType = getPrimitivePath(type.path);\n\n  try {\n    if (primType) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractPrimitivePath)[_extractPrimitivePath](lookupIndex, primType);\n    } else if (type.def.isArray) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractArray)[_extractArray](lookupIndex, type.def.asArray);\n    } else if (type.def.isBitSequence) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractBitSequence)[_extractBitSequence](lookupIndex, type.def.asBitSequence);\n    } else if (type.def.isCompact) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractCompact)[_extractCompact](lookupIndex, type.def.asCompact);\n    } else if (type.def.isComposite) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractComposite)[_extractComposite](lookupIndex, type, type.def.asComposite);\n    } else if (type.def.isHistoricMetaCompat) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractHistoric)[_extractHistoric](lookupIndex, type.def.asHistoricMetaCompat);\n    } else if (type.def.isPrimitive) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractPrimitive)[_extractPrimitive](lookupIndex, type);\n    } else if (type.def.isSequence) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractSequence)[_extractSequence](lookupIndex, type.def.asSequence);\n    } else if (type.def.isTuple) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractTuple)[_extractTuple](lookupIndex, type.def.asTuple);\n    } else if (type.def.isVariant) {\n      typeDef = _classPrivateFieldLooseBase(this, _extractVariant)[_extractVariant](lookupIndex, type, type.def.asVariant);\n    } else {\n      throw new Error(`No SiTypeDef handler for ${type.def.toString()}`);\n    }\n  } catch (error) {\n    throw new Error(`PortableRegistry: ${lookupIndex}${namespace ? ` (${namespace})` : ''}: Error extracting ${stringify(type)}: ${error.message}`);\n  }\n\n  return _objectSpread({\n    docs: type.docs.map(d => d.toString()),\n    namespace\n  }, typeDef);\n}\n\nfunction _extractArray2(_, {\n  len: length,\n  type\n}) {\n  assert(!length || length.toNumber() <= 256, 'Only support for [Type; <length>], where length <= 256');\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.VecFixed,\n    length: length.toNumber(),\n    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)\n  });\n}\n\nfunction _extractBitSequence2(_, {\n  bitOrderType,\n  bitStoreType\n}) {\n  const bitOrder = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](bitOrderType);\n\n  const bitStore = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](bitStoreType); // NOTE: Currently the BitVec type is one-way only, i.e. we only use it to decode, not\n  // re-encode stuff. As such we ignore the msb/lsb identifier given by bitOrderType, or rather\n  // we don't pass it though at all\n\n\n  assert(['bitvec::order::Lsb0', 'bitvec::order::Msb0'].includes(bitOrder.namespace || ''), () => `Unexpected bitOrder found as ${bitOrder.namespace || '<unknown>'}`);\n  assert(bitStore.info === TypeDefInfo.Plain && bitStore.type === 'u8', () => `Only u8 bitStore is currently supported, found ${bitStore.type}`);\n  return {\n    info: TypeDefInfo.Plain,\n    type: 'BitVec'\n  };\n}\n\nfunction _extractCompact2(_, {\n  type\n}) {\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Compact,\n    sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)\n  });\n}\n\nfunction _extractComposite2(lookupIndex, {\n  params,\n  path\n}, {\n  fields\n}) {\n  const specialVariant = path[0].toString();\n\n  if (path.length === 1 && specialVariant === 'BTreeMap') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.BTreeMap,\n      sub: params.map(({\n        type\n      }) => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type.unwrap()))\n    });\n  } else if (['Range', 'RangeInclusive'].includes(specialVariant)) {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Range,\n      sub: fields.map(({\n        name,\n        type\n      }, index) => _objectSpread({\n        name: name.isSome ? name.unwrap().toString() : ['start', 'end'][index]\n      }, _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type)))\n    });\n  } else if (path.length && path[path.length - 1].toString() === 'WrapperOpaque') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.WrapperOpaque,\n      sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap())\n    });\n  }\n\n  return SETS.some(p => matchParts(p, path)) ? _classPrivateFieldLooseBase(this, _extractCompositeSet)[_extractCompositeSet](lookupIndex, params, fields) : _classPrivateFieldLooseBase(this, _extractFields)[_extractFields](lookupIndex, fields);\n}\n\nfunction _extractCompositeSet2(_, params, fields) {\n  assert(params.length === 1 && fields.length === 1, 'Set handling expects param/field as single entries');\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Set,\n    length: this.registry.createType(this.registry.createLookupType(fields[0].type)).bitLength(),\n    sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(({\n      index,\n      name\n    }) => ({\n      // This will be an issue > 2^53 - 1 ... don't have those (yet)\n      index: index.toNumber(),\n      info: TypeDefInfo.Plain,\n      name: name.toString(),\n      type: 'Null'\n    }))\n  });\n}\n\nfunction _extractFields2(lookupIndex, fields) {\n  const [isStruct, isTuple] = fields.reduce(([isAllNamed, isAllUnnamed], {\n    name\n  }) => [isAllNamed && name.isSome, isAllUnnamed && name.isNone], [true, true]);\n  assert(isTuple || isStruct, 'Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)');\n\n  if (fields.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  } else if (isTuple && fields.length === 1) {\n    const typeDef = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](fields[0].type);\n\n    return _objectSpread(_objectSpread({}, typeDef), lookupIndex === -1 ? {} : {\n      lookupIndex,\n      lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n      lookupNameRoot: typeDef.lookupName\n    });\n  }\n\n  const [sub, alias] = _classPrivateFieldLooseBase(this, _extractFieldsAlias)[_extractFieldsAlias](fields);\n\n  return withTypeString(this.registry, _objectSpread(_objectSpread(_objectSpread({\n    info: isTuple // Tuple check first\n    ? TypeDefInfo.Tuple : TypeDefInfo.Struct\n  }, alias.size ? {\n    alias\n  } : {}), lookupIndex === -1 ? {} : {\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex]\n  }), {}, {\n    sub\n  }));\n}\n\nfunction _extractFieldsAlias2(fields) {\n  const alias = new Map();\n  const sub = fields.map(({\n    docs,\n    name,\n    type\n  }) => {\n    const typeDef = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type);\n\n    if (name.isNone) {\n      return typeDef;\n    }\n\n    let nameField = stringCamelCase(name.unwrap());\n    let nameOrig = null;\n\n    if (nameField.includes('#')) {\n      nameOrig = nameField;\n      nameField = nameOrig.replace(/#/g, '_');\n    } else if (RESERVED.includes(nameField)) {\n      nameOrig = nameField;\n      nameField = `${nameField}_`;\n    }\n\n    if (nameOrig) {\n      alias.set(nameField, nameOrig);\n    }\n\n    return _objectSpread(_objectSpread({}, typeDef), {}, {\n      docs: docs.map(d => d.toString()),\n      name: nameField\n    });\n  });\n  return [sub, alias];\n}\n\nfunction _extractHistoric2(_, type) {\n  return _objectSpread(_objectSpread({}, getTypeDef(type)), {}, {\n    displayName: type.toString(),\n    isFromSi: true\n  });\n}\n\nfunction _extractPrimitive2(_, type) {\n  const typeStr = type.def.asPrimitive.type.toString();\n  return {\n    info: TypeDefInfo.Plain,\n    type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()\n  };\n}\n\nfunction _extractPrimitivePath2(_, type) {\n  return {\n    info: TypeDefInfo.Plain,\n    type\n  };\n}\n\nfunction _extractSequence2(lookupIndex, {\n  type\n}) {\n  const sub = _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type);\n\n  if (sub.type === 'u8') {\n    return {\n      info: TypeDefInfo.Plain,\n      type: 'Bytes'\n    };\n  }\n\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Vec,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}\n\nfunction _extractTuple2(lookupIndex, ids) {\n  if (ids.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  } else if (ids.length === 1) {\n    return this.getTypeDef(ids[0]);\n  }\n\n  const sub = ids.map(type => _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type));\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Tuple,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}\n\nfunction _extractVariant2(lookupIndex, {\n  params,\n  path\n}, {\n  variants\n}) {\n  const specialVariant = path[0].toString();\n\n  if (specialVariant === 'Option') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Option,\n      sub: _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap())\n    });\n  } else if (specialVariant === 'Result') {\n    return withTypeString(this.registry, {\n      info: TypeDefInfo.Result,\n      sub: params.map(({\n        type\n      }, index) => _objectSpread({\n        name: ['Ok', 'Error'][index]\n      }, _classPrivateFieldLooseBase(this, _createSiDef)[_createSiDef](type.unwrap())))\n    });\n  } else if (variants.length === 0) {\n    return {\n      info: TypeDefInfo.Null,\n      type: 'Null'\n    };\n  }\n\n  return _classPrivateFieldLooseBase(this, _extractVariantEnum)[_extractVariantEnum](lookupIndex, variants);\n}\n\nfunction _extractVariantEnum2(lookupIndex, variants) {\n  const sub = []; // we may get entries out of order, arrange them first before creating with gaps filled\n  // NOTE: Since we mutate, use a copy of the array as an input\n\n  [...variants].sort((a, b) => a.index.cmp(b.index)).forEach(({\n    fields,\n    index,\n    name\n  }) => {\n    const desired = index.toNumber();\n\n    while (sub.length !== desired) {\n      sub.push({\n        index: sub.length,\n        info: TypeDefInfo.Null,\n        name: `Unused${sub.length}`,\n        type: 'Null'\n      });\n    }\n\n    sub.push(_objectSpread(_objectSpread({}, _classPrivateFieldLooseBase(this, _extractFields)[_extractFields](-1, fields)), {}, {\n      index: index.toNumber(),\n      name: name.toString()\n    }));\n  });\n  return withTypeString(this.registry, {\n    info: TypeDefInfo.Enum,\n    lookupIndex,\n    lookupName: _classPrivateFieldLooseBase(this, _names)[_names][lookupIndex],\n    sub\n  });\n}"]},"metadata":{},"sourceType":"module"}