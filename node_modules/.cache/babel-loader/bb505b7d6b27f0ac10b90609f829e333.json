{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { firstValueFrom, map, of, switchMap } from 'rxjs';\nimport { Metadata, TypeRegistry } from '@polkadot/types';\nimport { getSpecAlias, getSpecExtensions, getSpecHasher, getSpecRpc, getSpecTypes, getUpgradeVersion } from '@polkadot/types-known';\nimport { assert, BN_ZERO, isUndefined, logger, stringify, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { detectedCapabilities } from \"./capabilities.js\";\nimport { Decorate } from \"./Decorate.js\";\nconst KEEPALIVE_INTERVAL = 10000;\nconst l = logger('api/init');\n\nvar _healthTimer = /*#__PURE__*/_classPrivateFieldLooseKey(\"healthTimer\");\n\nvar _registries = /*#__PURE__*/_classPrivateFieldLooseKey(\"registries\");\n\nvar _updateSub = /*#__PURE__*/_classPrivateFieldLooseKey(\"updateSub\");\n\nvar _waitingRegistries = /*#__PURE__*/_classPrivateFieldLooseKey(\"waitingRegistries\");\n\nvar _onProviderConnect = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderConnect\");\n\nvar _onProviderDisconnect = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderDisconnect\");\n\nvar _onProviderError = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderError\");\n\nexport class Init extends Decorate {\n  constructor(options, type, decorateMethod) {\n    super(options, type, decorateMethod); // all injected types added to the registry for overrides\n\n    Object.defineProperty(this, _healthTimer, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _registries, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, _updateSub, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _waitingRegistries, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _onProviderConnect, {\n      writable: true,\n      value: async () => {\n        this._isConnected.next(true);\n\n        this.emit('connected');\n\n        try {\n          const [hasMeta, cryptoReady] = await Promise.all([this._loadMeta(), this._options.initWasm === false ? Promise.resolve(true) : cryptoWaitReady()]);\n\n          this._subscribeHealth();\n\n          if (hasMeta && !this._isReady && cryptoReady) {\n            this._isReady = true;\n            this.emit('ready', this);\n          }\n        } catch (_error) {\n          const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n          l.error(error);\n          this.emit('error', error);\n        }\n      }\n    });\n    Object.defineProperty(this, _onProviderDisconnect, {\n      writable: true,\n      value: () => {\n        this._isConnected.next(false);\n\n        this._unsubscribeHealth();\n\n        this.emit('disconnected');\n      }\n    });\n    Object.defineProperty(this, _onProviderError, {\n      writable: true,\n      value: error => {\n        this.emit('error', error);\n      }\n    });\n    this.registry.setKnownTypes(options); // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n\n    if (!options.source) {\n      this.registerTypes(options.types);\n    } else {\n      _classPrivateFieldLooseBase(this, _registries)[_registries] = _classPrivateFieldLooseBase(options.source, _registries)[_registries];\n    }\n\n    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n\n    if (this.supportMulti) {\n      this._queryMulti = this._decorateMulti(this._decorateMethod);\n      this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n    }\n\n    this._rx.signer = options.signer;\n\n    this._rpcCore.setRegistrySwap(blockHash => this.getBlockRegistry(blockHash));\n\n    if (this.hasSubscriptions) {\n      this._rpcCore.provider.on('disconnected', _classPrivateFieldLooseBase(this, _onProviderDisconnect)[_onProviderDisconnect]);\n\n      this._rpcCore.provider.on('error', _classPrivateFieldLooseBase(this, _onProviderError)[_onProviderError]);\n\n      this._rpcCore.provider.on('connected', _classPrivateFieldLooseBase(this, _onProviderConnect)[_onProviderConnect]);\n    } else {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    } // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n\n\n    if (this._rpcCore.provider.isConnected) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      _classPrivateFieldLooseBase(this, _onProviderConnect)[_onProviderConnect]();\n    }\n  }\n  /**\n   * @description Decorates a registry based on the runtime version\n   */\n\n\n  _initRegistry(registry, chain, version, metadata, chainProps) {\n    registry.setChainProperties(chainProps || this.registry.getChainProperties());\n    registry.setKnownTypes(this._options);\n    registry.register(getSpecTypes(registry, chain, version.specName, version.specVersion));\n    registry.setHasher(getSpecHasher(registry, chain, version.specName)); // for bundled types, pull through the aliases defined\n\n    if (registry.knownTypes.typesBundle) {\n      registry.knownTypes.typesAlias = getSpecAlias(registry, chain, version.specName);\n    }\n\n    registry.setMetadata(metadata, undefined, _objectSpread(_objectSpread({}, getSpecExtensions(registry, chain, version.specName)), this._options.signedExtensions || {}));\n  }\n  /**\n   * @description Returns the default versioned registry\n   */\n\n\n  _getDefaultRegistry() {\n    // get the default registry version\n    const thisRegistry = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n      isDefault\n    }) => isDefault);\n\n    assert(thisRegistry, 'Initialization error, cannot find the default registry');\n    return thisRegistry;\n  }\n  /**\n   * @description Returns a decorated API instance at a specific point in time\n   */\n\n\n  async at(blockHash) {\n    const u8aHash = u8aToU8a(blockHash);\n    const registry = await this.getBlockRegistry(u8aHash); // always create a new decoration for this specific hash\n\n    return this._createDecorated(registry, true, u8aHash).decoratedApi;\n  }\n\n  async _getBlockRegistry(blockHash) {\n    // ensure we have everything required\n    assert(this._genesisHash && this._runtimeVersion, 'Cannot retrieve data on an uninitialized chain'); // We have to assume that on the RPC layer the calls used here does not call back into\n    // the registry swap, so getHeader & getRuntimeVersion should not be historic\n\n    const header = this.registry.createType('HeaderPartial', this._genesisHash.eq(blockHash) ? {\n      number: BN_ZERO,\n      parentHash: this._genesisHash\n    } : await firstValueFrom(this._rpcCore.chain.getHeader.json(blockHash)));\n    assert(!header.parentHash.isEmpty, 'Unable to retrieve header and parent from supplied hash'); // get the runtime version, either on-chain or via an known upgrade history\n\n    const [firstVersion, lastVersion] = getUpgradeVersion(this._genesisHash, header.number);\n    const version = this.registry.createType('RuntimeVersionPartial', firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {\n      specName: this._runtimeVersion.specName,\n      specVersion: firstVersion.specVersion\n    } : await firstValueFrom(this._rpcCore.state.getRuntimeVersion.json(header.parentHash))); // check for pre-existing registries. We also check specName, e.g. it\n    // could be changed like in Westmint with upgrade from  shell -> westmint\n\n    const existingViaVersion = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n      specName,\n      specVersion\n    }) => specName.eq(version.specName) && specVersion.eq(version.specVersion));\n\n    if (existingViaVersion) {\n      existingViaVersion.lastBlockHash = blockHash;\n      return existingViaVersion;\n    } // nothing has been found, construct new\n\n\n    const registry = new TypeRegistry(blockHash);\n    const metadata = new Metadata(registry, await firstValueFrom(this._rpcCore.state.getMetadata.raw(header.parentHash)));\n\n    this._initRegistry(registry, this._runtimeChain, version, metadata); // add our new registry\n\n\n    const result = {\n      lastBlockHash: blockHash,\n      metadata,\n      registry,\n      specName: version.specName,\n      specVersion: version.specVersion\n    };\n\n    _classPrivateFieldLooseBase(this, _registries)[_registries].push(result);\n\n    return result;\n  }\n  /**\n   * @description Sets up a registry based on the block hash defined\n   */\n\n\n  async getBlockRegistry(blockHash) {\n    const existingViaHash = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n      lastBlockHash\n    }) => lastBlockHash && u8aEq(lastBlockHash, blockHash));\n\n    if (existingViaHash) {\n      return existingViaHash;\n    }\n\n    const blockHashHex = u8aToHex(blockHash);\n\n    let waiting = _classPrivateFieldLooseBase(this, _waitingRegistries)[_waitingRegistries][blockHashHex];\n\n    if (isUndefined(waiting)) {\n      waiting = this._getBlockRegistry(blockHash);\n      _classPrivateFieldLooseBase(this, _waitingRegistries)[_waitingRegistries][blockHashHex] = waiting; // when we have resolved, remove this from the waiting list\n\n      waiting.then(() => {\n        delete _classPrivateFieldLooseBase(this, _waitingRegistries)[_waitingRegistries][blockHashHex];\n      }).catch(() => undefined);\n    }\n\n    return waiting;\n  }\n\n  async _loadMeta() {\n    var _this$_options$source; // on re-connection to the same chain, we don't want to re-do everything from chain again\n\n\n    if (this._isReady) {\n      return true;\n    }\n\n    this._unsubscribeUpdates(); // only load from on-chain if we are not a clone (default path), alternatively\n    // just use the values from the source instance provided\n\n\n    [this._genesisHash, this._runtimeMetadata] = (_this$_options$source = this._options.source) !== null && _this$_options$source !== void 0 && _this$_options$source._isReady ? await this._metaFromSource(this._options.source) : await this._metaFromChain(this._options.metadata);\n    return this._initFromMeta(this._runtimeMetadata);\n  } // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  async _metaFromSource(source) {\n    this._extrinsicType = source.extrinsicVersion;\n    this._runtimeChain = source.runtimeChain;\n    this._runtimeVersion = source.runtimeVersion;\n    const methods = []; // manually build a list of all available methods in this RPC, we are\n    // going to filter on it to align the cloned RPC without making a call\n\n    Object.keys(source.rpc).forEach(section => {\n      Object.keys(source.rpc[section]).forEach(method => {\n        methods.push(`${section}_${method}`);\n      });\n    });\n\n    this._filterRpc(methods, getSpecRpc(this.registry, source.runtimeChain, source.runtimeVersion.specName));\n\n    return [source.genesisHash, source.runtimeMetadata];\n  }\n\n  _detectCapabilities(registry, blockHash) {\n    firstValueFrom(detectedCapabilities(this._rx, blockHash)).then(types => {\n      if (Object.keys(types).length) {\n        registry.register(types);\n        l.debug(() => `Capabilities detected${blockHash ? ` (${u8aToHex(u8aToU8a(blockHash))})` : ''}: ${stringify(types)}`);\n      }\n    }).catch(undefined);\n    return true;\n  } // subscribe to metadata updates, inject the types on changes\n\n\n  _subscribeUpdates() {\n    if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub] || !this.hasSubscriptions) {\n      return;\n    }\n\n    _classPrivateFieldLooseBase(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap(version => {\n      var _this$_runtimeVersion;\n\n      return (// only retrieve the metadata when the on-chain version has been changed\n        (_this$_runtimeVersion = this._runtimeVersion) !== null && _this$_runtimeVersion !== void 0 && _this$_runtimeVersion.specVersion.eq(version.specVersion) ? of(false) : this._rpcCore.state.getMetadata().pipe(map(metadata => {\n          l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n          this._runtimeMetadata = metadata;\n          this._runtimeVersion = version;\n          this._rx.runtimeVersion = version; // update the default registry version\n\n          const thisRegistry = this._getDefaultRegistry(); // setup the data as per the current versions\n\n\n          thisRegistry.metadata = metadata;\n          thisRegistry.specVersion = version.specVersion; // clear the registry types to ensure that we override correctly\n\n          this._initRegistry(thisRegistry.registry.init(), this._runtimeChain, version, metadata);\n\n          this._injectMetadata(thisRegistry, false);\n\n          return this._detectCapabilities(thisRegistry.registry);\n        }))\n      );\n    })).subscribe();\n  }\n\n  async _metaFromChain(optMetadata) {\n    const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods, chainMetadata] = await Promise.all([firstValueFrom(this._rpcCore.chain.getBlockHash(0)), firstValueFrom(this._rpcCore.state.getRuntimeVersion()), firstValueFrom(this._rpcCore.system.chain()), firstValueFrom(this._rpcCore.system.properties()), firstValueFrom(this._rpcCore.rpc.methods()), optMetadata ? Promise.resolve(null) : firstValueFrom(this._rpcCore.state.getMetadata())]); // set our chain version & genesisHash as returned\n\n    this._runtimeChain = chain;\n    this._runtimeVersion = runtimeVersion;\n    this._rx.runtimeVersion = runtimeVersion; // retrieve metadata, either from chain  or as pass-in via options\n\n    const metadataKey = `${genesisHash.toHex() || '0x'}-${runtimeVersion.specVersion.toString()}`;\n    const metadata = chainMetadata || (optMetadata && optMetadata[metadataKey] ? new Metadata(this.registry, optMetadata[metadataKey]) : await firstValueFrom(this._rpcCore.state.getMetadata())); // initializes the registry & RPC\n\n    this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);\n\n    this._filterRpc(rpcMethods.methods.map(t => t.toString()), getSpecRpc(this.registry, chain, runtimeVersion.specName));\n\n    this._subscribeUpdates(); // setup the initial registry, when we have none\n\n\n    if (!_classPrivateFieldLooseBase(this, _registries)[_registries].length) {\n      _classPrivateFieldLooseBase(this, _registries)[_registries].push({\n        isDefault: true,\n        metadata,\n        registry: this.registry,\n        specName: runtimeVersion.specName,\n        specVersion: runtimeVersion.specVersion\n      });\n    } // get unique types & validate\n\n\n    metadata.getUniqTypes(this._options.throwOnUnknown || false);\n    return [genesisHash, metadata];\n  }\n\n  _initFromMeta(metadata) {\n    this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();\n    this._rx.extrinsicType = this._extrinsicType;\n    this._rx.genesisHash = this._genesisHash;\n    this._rx.runtimeVersion = this._runtimeVersion; // must be set here\n    // inject metadata and adjust the types as detected\n\n    this._injectMetadata(this._getDefaultRegistry(), true); // derive is last, since it uses the decorated rx\n\n\n    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n    this._derive = this._decorateDerive(this._decorateMethod); // detect the on-chain capabilities\n\n    this._detectCapabilities(this.registry);\n\n    return true;\n  }\n\n  _subscribeHealth() {\n    // Only enable the health keepalive on WS, not needed on HTTP\n    _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = this.hasSubscriptions ? setInterval(() => {\n      firstValueFrom(this._rpcCore.system.health()).catch(() => undefined);\n    }, KEEPALIVE_INTERVAL) : null;\n  }\n\n  _unsubscribeHealth() {\n    if (_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]) {\n      clearInterval(_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]);\n      _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = null;\n    }\n  }\n\n  _unsubscribeUpdates() {\n    if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub]) {\n      _classPrivateFieldLooseBase(this, _updateSub)[_updateSub].unsubscribe();\n\n      _classPrivateFieldLooseBase(this, _updateSub)[_updateSub] = null;\n    }\n  }\n\n  _unsubscribe() {\n    this._unsubscribeHealth();\n\n    this._unsubscribeUpdates();\n  }\n\n}","map":{"version":3,"sources":["/Users/mario/p/dapp-test/node_modules/@polkadot/api/base/Init.js"],"names":["_defineProperty","_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","firstValueFrom","map","of","switchMap","Metadata","TypeRegistry","getSpecAlias","getSpecExtensions","getSpecHasher","getSpecRpc","getSpecTypes","getUpgradeVersion","assert","BN_ZERO","isUndefined","logger","stringify","u8aEq","u8aToHex","u8aToU8a","cryptoWaitReady","detectedCapabilities","Decorate","KEEPALIVE_INTERVAL","l","_healthTimer","_registries","_updateSub","_waitingRegistries","_onProviderConnect","_onProviderDisconnect","_onProviderError","Init","constructor","options","type","decorateMethod","writable","value","_isConnected","next","emit","hasMeta","cryptoReady","Promise","all","_loadMeta","_options","initWasm","resolve","_subscribeHealth","_isReady","_error","error","Error","message","_unsubscribeHealth","registry","setKnownTypes","registerTypes","types","_rpc","_decorateRpc","_rpcCore","_decorateMethod","_rx","rpc","_rxDecorateMethod","supportMulti","_queryMulti","_decorateMulti","queryMulti","signer","setRegistrySwap","blockHash","getBlockRegistry","hasSubscriptions","provider","on","warn","isConnected","_initRegistry","chain","version","metadata","chainProps","setChainProperties","getChainProperties","register","specName","specVersion","setHasher","knownTypes","typesBundle","typesAlias","setMetadata","undefined","signedExtensions","_getDefaultRegistry","thisRegistry","find","isDefault","at","u8aHash","_createDecorated","decoratedApi","_getBlockRegistry","_genesisHash","_runtimeVersion","header","createType","eq","number","parentHash","getHeader","json","isEmpty","firstVersion","lastVersion","state","getRuntimeVersion","existingViaVersion","lastBlockHash","getMetadata","raw","_runtimeChain","result","existingViaHash","blockHashHex","waiting","then","catch","_this$_options$source","_unsubscribeUpdates","_runtimeMetadata","_metaFromSource","_metaFromChain","_initFromMeta","_extrinsicType","extrinsicVersion","runtimeChain","runtimeVersion","methods","section","method","_filterRpc","genesisHash","runtimeMetadata","_detectCapabilities","debug","_subscribeUpdates","subscribeRuntimeVersion","pipe","_this$_runtimeVersion","log","toString","transactionVersion","init","_injectMetadata","subscribe","optMetadata","rpcMethods","chainMetadata","getBlockHash","system","properties","metadataKey","toHex","t","getUniqTypes","throwOnUnknown","asLatest","extrinsic","toNumber","extrinsicType","derive","_decorateDeriveRx","_derive","_decorateDerive","setInterval","health","clearInterval","unsubscribe","_unsubscribe"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { firstValueFrom, map, of, switchMap } from 'rxjs';\nimport { Metadata, TypeRegistry } from '@polkadot/types';\nimport { getSpecAlias, getSpecExtensions, getSpecHasher, getSpecRpc, getSpecTypes, getUpgradeVersion } from '@polkadot/types-known';\nimport { assert, BN_ZERO, isUndefined, logger, stringify, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { detectedCapabilities } from \"./capabilities.js\";\nimport { Decorate } from \"./Decorate.js\";\nconst KEEPALIVE_INTERVAL = 10000;\nconst l = logger('api/init');\n\nvar _healthTimer = /*#__PURE__*/_classPrivateFieldLooseKey(\"healthTimer\");\n\nvar _registries = /*#__PURE__*/_classPrivateFieldLooseKey(\"registries\");\n\nvar _updateSub = /*#__PURE__*/_classPrivateFieldLooseKey(\"updateSub\");\n\nvar _waitingRegistries = /*#__PURE__*/_classPrivateFieldLooseKey(\"waitingRegistries\");\n\nvar _onProviderConnect = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderConnect\");\n\nvar _onProviderDisconnect = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderDisconnect\");\n\nvar _onProviderError = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderError\");\n\nexport class Init extends Decorate {\n  constructor(options, type, decorateMethod) {\n    super(options, type, decorateMethod); // all injected types added to the registry for overrides\n\n    Object.defineProperty(this, _healthTimer, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _registries, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, _updateSub, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _waitingRegistries, {\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, _onProviderConnect, {\n      writable: true,\n      value: async () => {\n        this._isConnected.next(true);\n\n        this.emit('connected');\n\n        try {\n          const [hasMeta, cryptoReady] = await Promise.all([this._loadMeta(), this._options.initWasm === false ? Promise.resolve(true) : cryptoWaitReady()]);\n\n          this._subscribeHealth();\n\n          if (hasMeta && !this._isReady && cryptoReady) {\n            this._isReady = true;\n            this.emit('ready', this);\n          }\n        } catch (_error) {\n          const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n          l.error(error);\n          this.emit('error', error);\n        }\n      }\n    });\n    Object.defineProperty(this, _onProviderDisconnect, {\n      writable: true,\n      value: () => {\n        this._isConnected.next(false);\n\n        this._unsubscribeHealth();\n\n        this.emit('disconnected');\n      }\n    });\n    Object.defineProperty(this, _onProviderError, {\n      writable: true,\n      value: error => {\n        this.emit('error', error);\n      }\n    });\n    this.registry.setKnownTypes(options); // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n\n    if (!options.source) {\n      this.registerTypes(options.types);\n    } else {\n      _classPrivateFieldLooseBase(this, _registries)[_registries] = _classPrivateFieldLooseBase(options.source, _registries)[_registries];\n    }\n\n    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n\n    if (this.supportMulti) {\n      this._queryMulti = this._decorateMulti(this._decorateMethod);\n      this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n    }\n\n    this._rx.signer = options.signer;\n\n    this._rpcCore.setRegistrySwap(blockHash => this.getBlockRegistry(blockHash));\n\n    if (this.hasSubscriptions) {\n      this._rpcCore.provider.on('disconnected', _classPrivateFieldLooseBase(this, _onProviderDisconnect)[_onProviderDisconnect]);\n\n      this._rpcCore.provider.on('error', _classPrivateFieldLooseBase(this, _onProviderError)[_onProviderError]);\n\n      this._rpcCore.provider.on('connected', _classPrivateFieldLooseBase(this, _onProviderConnect)[_onProviderConnect]);\n    } else {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    } // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n\n\n    if (this._rpcCore.provider.isConnected) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      _classPrivateFieldLooseBase(this, _onProviderConnect)[_onProviderConnect]();\n    }\n  }\n  /**\n   * @description Decorates a registry based on the runtime version\n   */\n\n\n  _initRegistry(registry, chain, version, metadata, chainProps) {\n    registry.setChainProperties(chainProps || this.registry.getChainProperties());\n    registry.setKnownTypes(this._options);\n    registry.register(getSpecTypes(registry, chain, version.specName, version.specVersion));\n    registry.setHasher(getSpecHasher(registry, chain, version.specName)); // for bundled types, pull through the aliases defined\n\n    if (registry.knownTypes.typesBundle) {\n      registry.knownTypes.typesAlias = getSpecAlias(registry, chain, version.specName);\n    }\n\n    registry.setMetadata(metadata, undefined, _objectSpread(_objectSpread({}, getSpecExtensions(registry, chain, version.specName)), this._options.signedExtensions || {}));\n  }\n  /**\n   * @description Returns the default versioned registry\n   */\n\n\n  _getDefaultRegistry() {\n    // get the default registry version\n    const thisRegistry = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n      isDefault\n    }) => isDefault);\n\n    assert(thisRegistry, 'Initialization error, cannot find the default registry');\n    return thisRegistry;\n  }\n  /**\n   * @description Returns a decorated API instance at a specific point in time\n   */\n\n\n  async at(blockHash) {\n    const u8aHash = u8aToU8a(blockHash);\n    const registry = await this.getBlockRegistry(u8aHash); // always create a new decoration for this specific hash\n\n    return this._createDecorated(registry, true, u8aHash).decoratedApi;\n  }\n\n  async _getBlockRegistry(blockHash) {\n    // ensure we have everything required\n    assert(this._genesisHash && this._runtimeVersion, 'Cannot retrieve data on an uninitialized chain'); // We have to assume that on the RPC layer the calls used here does not call back into\n    // the registry swap, so getHeader & getRuntimeVersion should not be historic\n\n    const header = this.registry.createType('HeaderPartial', this._genesisHash.eq(blockHash) ? {\n      number: BN_ZERO,\n      parentHash: this._genesisHash\n    } : await firstValueFrom(this._rpcCore.chain.getHeader.json(blockHash)));\n    assert(!header.parentHash.isEmpty, 'Unable to retrieve header and parent from supplied hash'); // get the runtime version, either on-chain or via an known upgrade history\n\n    const [firstVersion, lastVersion] = getUpgradeVersion(this._genesisHash, header.number);\n    const version = this.registry.createType('RuntimeVersionPartial', firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {\n      specName: this._runtimeVersion.specName,\n      specVersion: firstVersion.specVersion\n    } : await firstValueFrom(this._rpcCore.state.getRuntimeVersion.json(header.parentHash))); // check for pre-existing registries. We also check specName, e.g. it\n    // could be changed like in Westmint with upgrade from  shell -> westmint\n\n    const existingViaVersion = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n      specName,\n      specVersion\n    }) => specName.eq(version.specName) && specVersion.eq(version.specVersion));\n\n    if (existingViaVersion) {\n      existingViaVersion.lastBlockHash = blockHash;\n      return existingViaVersion;\n    } // nothing has been found, construct new\n\n\n    const registry = new TypeRegistry(blockHash);\n    const metadata = new Metadata(registry, await firstValueFrom(this._rpcCore.state.getMetadata.raw(header.parentHash)));\n\n    this._initRegistry(registry, this._runtimeChain, version, metadata); // add our new registry\n\n\n    const result = {\n      lastBlockHash: blockHash,\n      metadata,\n      registry,\n      specName: version.specName,\n      specVersion: version.specVersion\n    };\n\n    _classPrivateFieldLooseBase(this, _registries)[_registries].push(result);\n\n    return result;\n  }\n  /**\n   * @description Sets up a registry based on the block hash defined\n   */\n\n\n  async getBlockRegistry(blockHash) {\n    const existingViaHash = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n      lastBlockHash\n    }) => lastBlockHash && u8aEq(lastBlockHash, blockHash));\n\n    if (existingViaHash) {\n      return existingViaHash;\n    }\n\n    const blockHashHex = u8aToHex(blockHash);\n\n    let waiting = _classPrivateFieldLooseBase(this, _waitingRegistries)[_waitingRegistries][blockHashHex];\n\n    if (isUndefined(waiting)) {\n      waiting = this._getBlockRegistry(blockHash);\n      _classPrivateFieldLooseBase(this, _waitingRegistries)[_waitingRegistries][blockHashHex] = waiting; // when we have resolved, remove this from the waiting list\n\n      waiting.then(() => {\n        delete _classPrivateFieldLooseBase(this, _waitingRegistries)[_waitingRegistries][blockHashHex];\n      }).catch(() => undefined);\n    }\n\n    return waiting;\n  }\n\n  async _loadMeta() {\n    var _this$_options$source;\n\n    // on re-connection to the same chain, we don't want to re-do everything from chain again\n    if (this._isReady) {\n      return true;\n    }\n\n    this._unsubscribeUpdates(); // only load from on-chain if we are not a clone (default path), alternatively\n    // just use the values from the source instance provided\n\n\n    [this._genesisHash, this._runtimeMetadata] = (_this$_options$source = this._options.source) !== null && _this$_options$source !== void 0 && _this$_options$source._isReady ? await this._metaFromSource(this._options.source) : await this._metaFromChain(this._options.metadata);\n    return this._initFromMeta(this._runtimeMetadata);\n  } // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  async _metaFromSource(source) {\n    this._extrinsicType = source.extrinsicVersion;\n    this._runtimeChain = source.runtimeChain;\n    this._runtimeVersion = source.runtimeVersion;\n    const methods = []; // manually build a list of all available methods in this RPC, we are\n    // going to filter on it to align the cloned RPC without making a call\n\n    Object.keys(source.rpc).forEach(section => {\n      Object.keys(source.rpc[section]).forEach(method => {\n        methods.push(`${section}_${method}`);\n      });\n    });\n\n    this._filterRpc(methods, getSpecRpc(this.registry, source.runtimeChain, source.runtimeVersion.specName));\n\n    return [source.genesisHash, source.runtimeMetadata];\n  }\n\n  _detectCapabilities(registry, blockHash) {\n    firstValueFrom(detectedCapabilities(this._rx, blockHash)).then(types => {\n      if (Object.keys(types).length) {\n        registry.register(types);\n        l.debug(() => `Capabilities detected${blockHash ? ` (${u8aToHex(u8aToU8a(blockHash))})` : ''}: ${stringify(types)}`);\n      }\n    }).catch(undefined);\n    return true;\n  } // subscribe to metadata updates, inject the types on changes\n\n\n  _subscribeUpdates() {\n    if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub] || !this.hasSubscriptions) {\n      return;\n    }\n\n    _classPrivateFieldLooseBase(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap(version => {\n      var _this$_runtimeVersion;\n\n      return (// only retrieve the metadata when the on-chain version has been changed\n        (_this$_runtimeVersion = this._runtimeVersion) !== null && _this$_runtimeVersion !== void 0 && _this$_runtimeVersion.specVersion.eq(version.specVersion) ? of(false) : this._rpcCore.state.getMetadata().pipe(map(metadata => {\n          l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n          this._runtimeMetadata = metadata;\n          this._runtimeVersion = version;\n          this._rx.runtimeVersion = version; // update the default registry version\n\n          const thisRegistry = this._getDefaultRegistry(); // setup the data as per the current versions\n\n\n          thisRegistry.metadata = metadata;\n          thisRegistry.specVersion = version.specVersion; // clear the registry types to ensure that we override correctly\n\n          this._initRegistry(thisRegistry.registry.init(), this._runtimeChain, version, metadata);\n\n          this._injectMetadata(thisRegistry, false);\n\n          return this._detectCapabilities(thisRegistry.registry);\n        }))\n      );\n    })).subscribe();\n  }\n\n  async _metaFromChain(optMetadata) {\n    const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods, chainMetadata] = await Promise.all([firstValueFrom(this._rpcCore.chain.getBlockHash(0)), firstValueFrom(this._rpcCore.state.getRuntimeVersion()), firstValueFrom(this._rpcCore.system.chain()), firstValueFrom(this._rpcCore.system.properties()), firstValueFrom(this._rpcCore.rpc.methods()), optMetadata ? Promise.resolve(null) : firstValueFrom(this._rpcCore.state.getMetadata())]); // set our chain version & genesisHash as returned\n\n    this._runtimeChain = chain;\n    this._runtimeVersion = runtimeVersion;\n    this._rx.runtimeVersion = runtimeVersion; // retrieve metadata, either from chain  or as pass-in via options\n\n    const metadataKey = `${genesisHash.toHex() || '0x'}-${runtimeVersion.specVersion.toString()}`;\n    const metadata = chainMetadata || (optMetadata && optMetadata[metadataKey] ? new Metadata(this.registry, optMetadata[metadataKey]) : await firstValueFrom(this._rpcCore.state.getMetadata())); // initializes the registry & RPC\n\n    this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);\n\n    this._filterRpc(rpcMethods.methods.map(t => t.toString()), getSpecRpc(this.registry, chain, runtimeVersion.specName));\n\n    this._subscribeUpdates(); // setup the initial registry, when we have none\n\n\n    if (!_classPrivateFieldLooseBase(this, _registries)[_registries].length) {\n      _classPrivateFieldLooseBase(this, _registries)[_registries].push({\n        isDefault: true,\n        metadata,\n        registry: this.registry,\n        specName: runtimeVersion.specName,\n        specVersion: runtimeVersion.specVersion\n      });\n    } // get unique types & validate\n\n\n    metadata.getUniqTypes(this._options.throwOnUnknown || false);\n    return [genesisHash, metadata];\n  }\n\n  _initFromMeta(metadata) {\n    this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();\n    this._rx.extrinsicType = this._extrinsicType;\n    this._rx.genesisHash = this._genesisHash;\n    this._rx.runtimeVersion = this._runtimeVersion; // must be set here\n    // inject metadata and adjust the types as detected\n\n    this._injectMetadata(this._getDefaultRegistry(), true); // derive is last, since it uses the decorated rx\n\n\n    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n    this._derive = this._decorateDerive(this._decorateMethod); // detect the on-chain capabilities\n\n    this._detectCapabilities(this.registry);\n\n    return true;\n  }\n\n  _subscribeHealth() {\n    // Only enable the health keepalive on WS, not needed on HTTP\n    _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = this.hasSubscriptions ? setInterval(() => {\n      firstValueFrom(this._rpcCore.system.health()).catch(() => undefined);\n    }, KEEPALIVE_INTERVAL) : null;\n  }\n\n  _unsubscribeHealth() {\n    if (_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]) {\n      clearInterval(_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]);\n      _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = null;\n    }\n  }\n\n  _unsubscribeUpdates() {\n    if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub]) {\n      _classPrivateFieldLooseBase(this, _updateSub)[_updateSub].unsubscribe();\n\n      _classPrivateFieldLooseBase(this, _updateSub)[_updateSub] = null;\n    }\n  }\n\n  _unsubscribe() {\n    this._unsubscribeHealth();\n\n    this._unsubscribeUpdates();\n  }\n\n}"]},"metadata":{},"sourceType":"module"}