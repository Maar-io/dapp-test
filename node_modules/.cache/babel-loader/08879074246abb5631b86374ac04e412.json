{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// we are attempting to avoid circular refs, hence the path import\nimport { getTypeDef } from \"../../create/getTypeDef.js\";\nimport { TypeDefInfo } from \"../../create/types.js\";\n\nfunction extractSubSingle({\n  lookupName,\n  type\n}) {\n  return extractTypes([lookupName || type]);\n}\n\nfunction extractSubArray(types) {\n  return extractTypes(types.map(({\n    lookupName,\n    type\n  }) => lookupName || type));\n}\n/** @internal */\n\n\nexport function extractTypes(types) {\n  return types.map(type => {\n    const decoded = getTypeDef(type);\n\n    switch (decoded.info) {\n      case TypeDefInfo.Plain:\n        return decoded.lookupName || decoded.type;\n\n      case TypeDefInfo.BTreeSet:\n      case TypeDefInfo.Compact:\n      case TypeDefInfo.Option:\n      case TypeDefInfo.Vec:\n      case TypeDefInfo.VecFixed:\n      case TypeDefInfo.WrapperOpaque:\n        return extractSubSingle(decoded.sub);\n\n      case TypeDefInfo.BTreeMap:\n      case TypeDefInfo.Enum:\n      case TypeDefInfo.HashMap:\n      case TypeDefInfo.Result:\n      case TypeDefInfo.Set:\n      case TypeDefInfo.Struct:\n      case TypeDefInfo.Tuple:\n        return extractSubArray(decoded.sub);\n\n      default:\n        throw new Error(`Unhandled: Unable to create and validate type from ${type} (info=${TypeDefInfo[decoded.info]})`);\n    }\n  });\n}","map":{"version":3,"sources":["/Users/mario/p/dapp-test/node_modules/@polkadot/types/metadata/util/extractTypes.js"],"names":["getTypeDef","TypeDefInfo","extractSubSingle","lookupName","type","extractTypes","extractSubArray","types","map","decoded","info","Plain","BTreeSet","Compact","Option","Vec","VecFixed","WrapperOpaque","sub","BTreeMap","Enum","HashMap","Result","Set","Struct","Tuple","Error"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,UAAT,QAA2B,4BAA3B;AACA,SAASC,WAAT,QAA4B,uBAA5B;;AAEA,SAASC,gBAAT,CAA0B;AACxBC,EAAAA,UADwB;AAExBC,EAAAA;AAFwB,CAA1B,EAGG;AACD,SAAOC,YAAY,CAAC,CAACF,UAAU,IAAIC,IAAf,CAAD,CAAnB;AACD;;AAED,SAASE,eAAT,CAAyBC,KAAzB,EAAgC;AAC9B,SAAOF,YAAY,CAACE,KAAK,CAACC,GAAN,CAAU,CAAC;AAC7BL,IAAAA,UAD6B;AAE7BC,IAAAA;AAF6B,GAAD,KAGxBD,UAAU,IAAIC,IAHA,CAAD,CAAnB;AAID;AACD;;;AAGA,OAAO,SAASC,YAAT,CAAsBE,KAAtB,EAA6B;AAClC,SAAOA,KAAK,CAACC,GAAN,CAAUJ,IAAI,IAAI;AACvB,UAAMK,OAAO,GAAGT,UAAU,CAACI,IAAD,CAA1B;;AAEA,YAAQK,OAAO,CAACC,IAAhB;AACE,WAAKT,WAAW,CAACU,KAAjB;AACE,eAAOF,OAAO,CAACN,UAAR,IAAsBM,OAAO,CAACL,IAArC;;AAEF,WAAKH,WAAW,CAACW,QAAjB;AACA,WAAKX,WAAW,CAACY,OAAjB;AACA,WAAKZ,WAAW,CAACa,MAAjB;AACA,WAAKb,WAAW,CAACc,GAAjB;AACA,WAAKd,WAAW,CAACe,QAAjB;AACA,WAAKf,WAAW,CAACgB,aAAjB;AACE,eAAOf,gBAAgB,CAACO,OAAO,CAACS,GAAT,CAAvB;;AAEF,WAAKjB,WAAW,CAACkB,QAAjB;AACA,WAAKlB,WAAW,CAACmB,IAAjB;AACA,WAAKnB,WAAW,CAACoB,OAAjB;AACA,WAAKpB,WAAW,CAACqB,MAAjB;AACA,WAAKrB,WAAW,CAACsB,GAAjB;AACA,WAAKtB,WAAW,CAACuB,MAAjB;AACA,WAAKvB,WAAW,CAACwB,KAAjB;AACE,eAAOnB,eAAe,CAACG,OAAO,CAACS,GAAT,CAAtB;;AAEF;AACE,cAAM,IAAIQ,KAAJ,CAAW,sDAAqDtB,IAAK,UAASH,WAAW,CAACQ,OAAO,CAACC,IAAT,CAAe,GAAxG,CAAN;AAtBJ;AAwBD,GA3BM,CAAP;AA4BD","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n// we are attempting to avoid circular refs, hence the path import\nimport { getTypeDef } from \"../../create/getTypeDef.js\";\nimport { TypeDefInfo } from \"../../create/types.js\";\n\nfunction extractSubSingle({\n  lookupName,\n  type\n}) {\n  return extractTypes([lookupName || type]);\n}\n\nfunction extractSubArray(types) {\n  return extractTypes(types.map(({\n    lookupName,\n    type\n  }) => lookupName || type));\n}\n/** @internal */\n\n\nexport function extractTypes(types) {\n  return types.map(type => {\n    const decoded = getTypeDef(type);\n\n    switch (decoded.info) {\n      case TypeDefInfo.Plain:\n        return decoded.lookupName || decoded.type;\n\n      case TypeDefInfo.BTreeSet:\n      case TypeDefInfo.Compact:\n      case TypeDefInfo.Option:\n      case TypeDefInfo.Vec:\n      case TypeDefInfo.VecFixed:\n      case TypeDefInfo.WrapperOpaque:\n        return extractSubSingle(decoded.sub);\n\n      case TypeDefInfo.BTreeMap:\n      case TypeDefInfo.Enum:\n      case TypeDefInfo.HashMap:\n      case TypeDefInfo.Result:\n      case TypeDefInfo.Set:\n      case TypeDefInfo.Struct:\n      case TypeDefInfo.Tuple:\n        return extractSubArray(decoded.sub);\n\n      default:\n        throw new Error(`Unhandled: Unable to create and validate type from ${type} (info=${TypeDefInfo[decoded.info]})`);\n    }\n  });\n}"]},"metadata":{},"sourceType":"module"}